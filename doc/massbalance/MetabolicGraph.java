/**
 * 
 */
package massbalance;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.MathContext;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.TreeMap;

import org.jgrapht.Graphs;
import org.jgrapht.alg.StrongConnectivityInspector;
import org.jgrapht.graph.DefaultWeightedEdge;
import org.jgrapht.graph.SimpleDirectedWeightedGraph;

/**
 * Objects of this class represent a metabolic network as a directed weighted bipartite graph.
 * It includes methods for graph modification, randomization and calculation of graph properties.
 * 
 * @author Georg Basler
 *
 */
public class MetabolicGraph extends SimpleDirectedWeightedGraph<Vertex,DefaultWeightedEdge> {
	
	/**
	 * Static initializer for loading the configuration parameters.
	 */
	static {
		Utilities.loadConfiguration();
	}
	  
	// Class version identifier for serialization, generated by eclipse. 
	private static final long serialVersionUID = 2925850334894946865L;
	
	public String version;
	private final boolean reversible;
	private final boolean compartments;
	
	// vertex hash maps for efficient retrieval
	private HashMap<String, Vertex> compounds;
	private HashMap<String, Vertex> reactions;
	
	// the phosphate vertices in the graph
	private HashMap<String, Vertex> phosphates;
	private HashMap<String, Vertex> hydrogens;
	
	// random walk visits
	private HashMap<MetabolicGraph,Integer> visits;
	
	/**
	 * The possible single compound and pair substitutions for a reaction, each consisting of 3-tuples 
	 * of (pairs of) compound vertices, stoichiometric coefficients, and the (pairs of) edge indices corresponding
	 * to a unique original substrate or product (pair).
	 *  
	 * @author Georg Basler
	 *
	 */
	protected class Substitutions {
		// singles
		ArrayList<Vertex> substitutes;
		ArrayList<int[]> stoichiometry;
		ArrayList<Integer> edgeIndices;
		// pairs
		ArrayList<Vertex> substitutePairs;
		ArrayList<int[]> stoichiometryPairs;
		ArrayList<Integer> edgePairIndices;
		
		boolean modifiable = false;
		
		private Substitutions(int degree) {
			substitutes = new ArrayList<Vertex>(degree*2);
			stoichiometry = new ArrayList<int[]>(degree*2);
			edgeIndices = new ArrayList<Integer>(degree*2);
			substitutePairs = new ArrayList<Vertex>(degree*degree-degree);
			stoichiometryPairs = new ArrayList<int[]>((degree*degree-degree)/2);
			edgePairIndices = new ArrayList<Integer>(degree*degree-degree);
		}
		
		/**
		 * Add a new single compound substitution.
		 */
		private void addSingle(Vertex substitute, int[] stoichiometry, Integer edgeIndex) {
			this.substitutes.add(substitute);
			this.stoichiometry.add(stoichiometry);
			this.edgeIndices.add(edgeIndex);
		}
		
		/**
		 * Add a new substitution of a compound pair.
		 */
		private void addPair(Vertex substitute1, Vertex substitute2, int[] stoichiometry, Integer edgeIndex1, Integer edgeIndex2) {
			this.substitutePairs.add(substitute1);
			this.substitutePairs.add(substitute2);
			this.stoichiometryPairs.add(stoichiometry);
			this.edgePairIndices.add(edgeIndex1);
			this.edgePairIndices.add(edgeIndex2);
		}
	}
	
	/**
	 * Creates an empty MetabolicGraph, a SimpleDirectedWeightedGraph.
	 * 
	 */
	public MetabolicGraph(boolean reversible, boolean compartments) {
		super(DefaultWeightedEdge.class);
		this.reversible = reversible;
		this.compartments = compartments;
		phosphates = new HashMap<String, Vertex>();
		hydrogens = new HashMap<String, Vertex>();
		compounds = new HashMap<String, Vertex>();
		reactions = new HashMap<String, Vertex>();
	}
	
	/**
	 * Creates a MetabolicGraph using numberOfCompounds as initial compounds hash capacity.
	 * 
	 * @param numberOfCompounds
	 * @param reversible
	 */
	public MetabolicGraph(String version, int numberOfCompounds, boolean reversible, boolean compartments) {
		super(DefaultWeightedEdge.class);
		this.version = version;
		this.reversible = reversible;
		this.compartments = compartments;
		phosphates = new HashMap<String, Vertex>();
		hydrogens = new HashMap<String, Vertex>();
		compounds = new HashMap<String, Vertex>(numberOfCompounds, 1f);
		reactions = new HashMap<String, Vertex>((int)(Utilities.DEFAULT_NUMBER_OF_REACTIONS/0.75f), 0.75f);
	}
	
	/**
	 * Indicates whether the graph is reversible, i.e., for each reaction a reversed
	 * reaction is added implicitly, which converts the products into the substrates. 
	 * 
	 * @return true, if the graph is reversible, false otherwise.
	 */
	public boolean isReversible() {
		return reversible;
	}
	
	/**
	 * Indicates whether the graph has compartments, i.e., each compound vertex
	 * is specified by a unique pair of a name and compartment. 
	 * 
	 * @return true, if the graph supports compartments, false otherwise.
	 */
	public boolean hasCompartments() {
		return compartments;
	}
	
	/**
	 * Returns the compound vertex with the specified name and compartment.
	 * Compartment may be null only if the graph does not support compartments.
	 * 
	 * @param name
	 * @param compartment
	 * @return Compound vertex.
	 */
	public Vertex getCompound(String name, String compartment) {
		if (this.compartments && (compartment == null || compartment.length() == 0))
			throw new IllegalArgumentException("Missing compartment for compound "+name+".");
		
		return this.compounds.get(name+compartment);
	}
	
	/**
	 * Returns an immutable collection of the compound vertices.
	 * 
	 * @return Collection of compound vertices.
	 */
	public Collection<Vertex> getCompounds() {
		return Collections.unmodifiableCollection(this.compounds.values());
	}

	/**
	 * Returns the reaction vertex with the specified name.
	 * 
	 * @param name
	 * @return Reaction vertex.
	 */
	public Vertex getReaction(String name) {
		return this.reactions.get(name);
	}
	
	/**
	 * Returns an immutable collection of the reaction vertices. Only the vertices
	 * representing the forward direction of reversible reactions are included.
	 * 
	 * @return Collection of the reaction vertices.
	 */
	public Collection<Vertex> getReactions() {
		return Collections.unmodifiableCollection(this.reactions.values());
	}

	/**
	 * Returns the set of reactions names in the graph. Only the names
	 * representing the forward direction of reversible reactions are included.
	 * 
	 * @return Set of reaction names.
	 */
	public Set<String> getReactionNames() {
		return this.reactions.keySet();
	}
	
	/**
	 * Returns the equation of the given reaction in the given graph as String.
	 * 
	 * @param reaction
	 * @return The reaction equation as String.
	 */
	public String getReactionEquation(MetabolicGraph graph, Vertex reaction) {
		String equation = "";
		
		if (reaction.getType() != Vertex.REACTION)
			throw new IllegalArgumentException("Only vertices of type Vertex.REACTION allowed.");
		
		// append the left equation side
		for (Iterator<Vertex> it = Graphs.predecessorListOf(graph, reaction).iterator(); it.hasNext(); ) {
			Vertex substrate = it.next();
			double weight = graph.getEdgeWeight(graph.getEdge(substrate, reaction));
			// add coefficient
			if (weight != 1)
				equation += Utilities.DELIMITER_COEFFICIENT_START + String.valueOf(weight) + Utilities.DELIMITER_COEFFICIENT_END + " ";
			// add substrate name and compartment
			equation += substrate.getName() + (hasCompartments()?Utilities.DELIMITER_COMPOUND_COMPARTMENT+substrate.getCompartment():"") + " ";
			if (it.hasNext())
				equation += Utilities.DELIMITER_PLUS + " ";
		}
		
		// append the side separator
		if (reaction.reversedReaction() == null)
			equation += Utilities.DELIMITER_FORWARD + " ";
		else
			equation += Utilities.DELIMITER_EQUALS + " ";
		
		// append the right equation side
		for (Iterator<Vertex> it = Graphs.successorListOf(graph, reaction).iterator(); it.hasNext(); ) {
			Vertex product = it.next();
			double weight = graph.getEdgeWeight(graph.getEdge(reaction, product));
			// add coefficient
			if (weight != 1)
				equation += Utilities.DELIMITER_COEFFICIENT_START + String.valueOf(weight) + Utilities.DELIMITER_COEFFICIENT_END + " ";
			// add substrate name and compartment
			equation += product.getName() + (hasCompartments()?Utilities.DELIMITER_COMPOUND_COMPARTMENT+product.getCompartment():"") + " ";
			if (it.hasNext())
				equation += Utilities.DELIMITER_PLUS + " ";
		}
		
		return equation.trim();
	}
	
	/**
	 * Fixes the stoichiometry of the reaction by finding the smallest factor
	 * such that for all compounds i: factor*weight[i] is an integer.
	 * 
	 * Returns the factor by which the weights were multiplied.
	 * 
	 * @param reaction
	 * @return The factor by which the stoichiometry was multiplied.
	 */
	public BigDecimal fixStoichiometry(Vertex reaction) {
		boolean debug = false;
		Set<DefaultWeightedEdge> edges = edgesOf(reaction);
		BigDecimal[] weights = new BigDecimal[edges.size()];
		long[] intWeights = new long[edges.size()];
		long factor = 1;
		
		if (edges.size() == 0)
			return BigDecimal.ONE;
		
		// find a factor, such that all weights*factor are integers
		int i=0;
		for (Iterator<DefaultWeightedEdge> edgeIterator = edges.iterator(); edgeIterator.hasNext(); i++) {
			// here a string is necessary to get a precise value from double
			DefaultWeightedEdge edge = edgeIterator.next();
			weights[i] = new BigDecimal(String.valueOf(getEdgeWeight(edge)));
			long m = 1, timeout = 1000000;
			// find the smallest factor such that weight*factor is an integer
			while (weights[i].multiply(new BigDecimal(m)).stripTrailingZeros().scale() > 0 && m <= timeout)
				m++;
			if (m > timeout) {
				throw new RuntimeException("No integer stoichiometry found for edge: "+getEdgeSource(edge).getName()+" -> "+getEdgeTarget(edge).getName()+", weight: "+weights[i].toString()+" in reaction "+reaction.getName()+" up to a factor of "+timeout+".");
			}
			if (Math.max(factor, m) % Math.min(factor, m) == 0) {
				factor = Math.max(factor, m);
			} else {
				// NOTE: could be replaced by the least common integer multiple
				factor *= m;
			}
			if (debug)
				System.out.print(weights[i]+" ");
		}
		if (debug)
			System.out.print("factor="+factor+" ");
		
		// get the integer weights
		for (int j=0; j<weights.length; j++)
			intWeights[j] = weights[j].multiply(new BigDecimal(String.valueOf(factor))).longValue();
		
		// divide the weights by the greatest common divisor
		long gcd = Utilities.gcd(intWeights);
		if (debug) {
			System.out.print(" gcd="+gcd);
			System.out.println();
		}
		if (factor != 1 || gcd != 1) {
			i=0;
			for (Iterator<DefaultWeightedEdge> edgeIterator = edges.iterator(); edgeIterator.hasNext(); i++) {
				setEdgeWeight(edgeIterator.next(), intWeights[i]/gcd);
				if (debug)
					System.out.print((intWeights[i]/gcd)+" ");
			}
			if (debug)
				System.out.println("fixed by "+(factor/gcd)+".");
		}
		
		if (debug) {
			System.out.print("Fixed reaction: ");
			Utilities.printReaction(this, reaction, true, true);
		}
		
		return new BigDecimal(factor).divide(new BigDecimal(gcd), 6, RoundingMode.HALF_UP);
	}
	
	/**
	 * @deprecated
	 * @param x
	 */
	public void leastIntegerMultiple(BigDecimal x) {
		int factor = 2;
		
		while (factor < 100) {
			try {
				x.intValueExact();
				break;
			} catch (ArithmeticException e) {
				x = x.multiply(new BigDecimal(String.valueOf(factor)));
				factor++;
			}
		}
		
		if (factor < 100)
			System.out.println(factor+"("+x.intValueExact()+")");
		else
			System.out.println("factor>=100");
	}
	
	/**
	 * @deprecated
	 * @param x
	 * @param y
	 */	
	public void leastIntegerMultiple(BigDecimal x, BigDecimal y) {
		int factor = 2;
		
		while (factor < 100) {
			try {
				x.intValueExact();
				y.intValueExact();
				break;
			} catch (ArithmeticException e) {
				x = x.multiply(new BigDecimal(String.valueOf(factor)));
				y = y.multiply(new BigDecimal(String.valueOf(factor)));
				factor++;
			}
		}
		
		if (factor < 100)
			System.out.println(factor+"("+x.intValueExact()+", "+y.intValueExact()+")");
		else
			System.out.println("factor>=100");
	}
	
	/**
	 * Determines the mass balance of a reaction by summing over the substrate and product masses,
	 * multiplied by the corresponding stoichiometric coefficients. Returns a vector of atom imbalances
	 * with values <0 indicating atoms missing on the left side, values >0 indicating atoms in excess
	 * on the left side, and values == 0 indicating atom balance. Returns null if the reaction contains
	 * an unannotated compound.
	 * 
	 * @param reaction
	 * @return A vector of imbalances or null, if the reaction contains an unannotated compound.
	 */
	public int[] balance(Vertex reaction) {
		int[] imbalance = new int[Utilities.ELEMENTS.length];
		
		if (reaction.getType() != Vertex.REACTION || reaction.isReversed())
			throw new IllegalArgumentException("Only vertices of type Vertex.REACTION and !Vertex.isReversed() allowed.");
		
		Set<DefaultWeightedEdge> edges = edgesOf(reaction);
		int[] leftSide = new int[Utilities.ELEMENTS.length];
		int[] rightSide = new int[Utilities.ELEMENTS.length];
		boolean left = true;
		
		// iterate over the reactions' substrates and products
		for (Iterator<DefaultWeightedEdge> edgeIterator = edges.iterator(); edgeIterator.hasNext(); ) {
			DefaultWeightedEdge edge = edgeIterator.next();
			Vertex compound;
			
			if (getEdgeSource(edge).getType() == Vertex.COMPOUND) {
				compound = getEdgeSource(edge);
				left = true;
			} else if (getEdgeTarget(edge).getType() == Vertex.COMPOUND) {
				compound = getEdgeTarget(edge);
				left = false;
			} else
				throw new RuntimeException("Graph not bipartite!");
			
			if (compound.getMass() == null) {
				return null;
			} else {
				// sum over substrate and product masses, multiplied by the stoichiometric coefficient
				if (left)
					leftSide = Equivalence.sumMasses(leftSide, Equivalence.multiplyMass(compound.getMass(), (int)getEdgeWeight(edge)));
				else
					rightSide = Equivalence.sumMasses(rightSide, Equivalence.multiplyMass(compound.getMass(), (int)getEdgeWeight(edge)));
			}
		}
		// calculate the imbalance
		for (int i=0; i<leftSide.length; i++)
			imbalance[i] = leftSide[i] - rightSide[i];
		
		return imbalance;
	}
	
	protected int fixBalance(Vertex reaction, int hydrogenImbalance, boolean phosphateFix, boolean hydrogenFix, BufferedWriter infoWriter) throws IOException {
		int added = -1;
		
		if (!phosphateFix && !hydrogenFix)
			throw new IllegalArgumentException("Either phosphateFix or hydrogenFix must be true.");
		if (reaction.getType() != Vertex.REACTION || reaction.isReversed())
			throw new IllegalArgumentException("Vertex must be of type Vertex.REACTION and !Vertex.isReversed().");
		if (hydrogenImbalance == 0)
			throw new IllegalArgumentException("Hydrogen imbalance must not be equal to 0.");
		
		// check if the reaction has a phosphate and/or hydrogen
		Vertex phosphate = null, hydrogen = null;
		for (Iterator<DefaultWeightedEdge> edges = edgesOf(reaction).iterator(); edges.hasNext();) {
			DefaultWeightedEdge edge = edges.next();
			Vertex compound = (getEdgeTarget(edge).equals(reaction) ? getEdgeSource(edge) : getEdgeTarget(edge));
			int phosphateType = Properties.isPhosphate(compound.getMass());
			if (phosphateType >= 0)
				phosphate = compound;
			else if (Properties.isHydrogen(compound.getMass()))
				hydrogen = compound;
		}
	
		if (phosphate != null && phosphateFix)
			added = fixPhosphate(reaction, phosphate, hydrogenImbalance, infoWriter);
		
		if (hydrogenFix && added == -1)
			added = fixHydrogen(reaction, hydrogen, hydrogenImbalance, infoWriter);
		
		return added;
	}
	
	/**
	 * Tries to fix a reaction with hydrogen imbalance that contains a phosphate. The phosphate is
	 * exchanged by a form with a different number of hydrogen atoms, if this fixes the mass balance,
	 * and true is returned. If no fix is possible, false is returned.
	 * 
	 * TODO reactions containing more than one phosphate are only checked for a fix by the first found phosphate. 
	 * Therefore, 3.6.3.27-RXN in ecocyc12.5, which has Pi as substrate and 2*Pi as products, and
	 * a hydrogen imbalance of +3, is not fixed by phosphate.  
	 * 
	 * @param reaction
	 * @param hydrogenImbalance
	 * @param infoWriter
	 * @return
	 * @throws IOException
	 */
	private int fixPhosphate(Vertex reaction, Vertex phosphate, int hydrogenImbalance, BufferedWriter infoWriter) throws IOException {
		boolean debug = false;
		boolean left = true;
		int added = 0;
		
		if (hydrogenImbalance < -3 || hydrogenImbalance > 3)
			return -1;
		
		DefaultWeightedEdge edge = getEdge(phosphate, reaction);
		if (edge == null) {
			edge = getEdge(reaction, phosphate);
			left = false;
		}
		
		int weight = (int)getEdgeWeight(edge);
		int hydrogenAtoms = (left ? -weight : weight) * Properties.isPhosphate(phosphate.getMass());
		int imbalance = hydrogenAtoms + hydrogenImbalance;
		
		// check if a fix is possible: (1) imbalance within the range of 3 phosphate hydrogen counts,
		// (2) imbalance and phosphate are on corresponding sides, (3) division of hydrogen atoms by weight is possible		
		if (Math.abs(imbalance) > 3 || (hydrogenAtoms != 0 && Math.abs(hydrogenImbalance) > Math.abs(hydrogenAtoms))
				|| (left && hydrogenAtoms == 0 && hydrogenImbalance > 0) || (!left && hydrogenAtoms == 0 && hydrogenImbalance < 0) || imbalance % weight != 0) {
			if (debug)
				System.out.println("Cannot fix "+reaction.getName()+" with phosphate "+(left?"left, ":"right, ")+(phosphate==null? "phosphate==null, " : "")+"hydrogen imbalance="+hydrogenImbalance+", phosphate hydrogen atoms="+hydrogenAtoms+", weight="+weight+".");
			return -1;
		} else {
			// determine the balancing phosphate type and get its vertex 
			int newType = Math.abs(imbalance/weight);
			Vertex newPhosphate = phosphates.get(phosphate.getCompartment()+newType);
			if (newPhosphate == null || !containsVertex(newPhosphate)) {
				newPhosphate = new Vertex(Utilities.PHOSPHATE_NAMES[newType], Utilities.PHOSPHATE_FORMS[newType], phosphate.getCompartment());
				addVertex(newPhosphate);
				added++;
				infoWriter.write("Added "+Utilities.PHOSPHATE_NAMES[newType]+" vertex for fixing mass balance\n");
			}
			// exchange the phosphate by the balancing type
			if (left) {
				removeEdge(phosphate, reaction);
				setEdgeWeight(addEdge(newPhosphate, reaction), weight);
			} else {
				removeEdge(reaction, phosphate);
				setEdgeWeight(addEdge(reaction, newPhosphate), weight);
			}
			
			String message = "Fixed reaction "+reaction.getName()+" by replacing "+phosphate.getName()+" with "+newPhosphate.getName()+(compartments?" in "+newPhosphate.getCompartment()+".":"");
			infoWriter.write(message+"\n");
			if (debug)
				System.out.println(message);
			
			if (debug) {
				// check if we did everything right
				int[] check = balance(reaction);
				for (int i=0; i<check.length; i++)
					if (check[i] != 0)
						throw new RuntimeException("Reaction "+reaction.getName()+" not balanced in "+Utilities.ELEMENTS[i]+" ("+check[i]+").");
			}
			
			return added;
		}
	}
	
	private int fixHydrogen(Vertex reaction, Vertex hydrogen, int hydrogenImbalance, BufferedWriter infoWriter) throws IOException {
		boolean debug = false;
		int added = 0;
		
		DefaultWeightedEdge leftEdge = getEdge(hydrogen, reaction);
		DefaultWeightedEdge rightEdge = getEdge(reaction, hydrogen);
		
		if (hydrogen != null && (hydrogenImbalance < 0 && leftEdge != null || hydrogenImbalance > 0 && rightEdge != null)) {
			// increase the coefficient accordingly
			if (hydrogenImbalance < 0)
				setEdgeWeight(leftEdge, getEdgeWeight(leftEdge)-hydrogenImbalance);
			else
				setEdgeWeight(rightEdge, getEdgeWeight(rightEdge)+hydrogenImbalance);
			
			String message = "Fixed reaction "+reaction.getName()+" by increasing hydrogen coefficient by "+Math.abs(hydrogenImbalance)+".";
			infoWriter.write(message+"\n");
			if (debug)
				System.out.println(message);
			
		} else {
			// find an existing hydrogen in the compartment(s) of the reaction
			for (String compartment : getCompartments(reaction).keySet()) {
				hydrogen = hydrogens.get(compartment);
				if (hydrogen != null)
					break;
			}
			
			// create new hydrogen vertex for the compartment
			if (hydrogen == null) {
				// add the hydrogen in the compartment of a compound on the same side of the reaction 
				String compartment = (hydrogenImbalance<0 ? Graphs.predecessorListOf(this, reaction).iterator().next().getCompartment() : Graphs.successorListOf(this, reaction).iterator().next().getCompartment());
				hydrogen = new Vertex(Utilities.HYDROGEN_NAME, Utilities.HYDROGEN_MASS, compartment);
				addVertex(hydrogen);
				added++;
				infoWriter.write("Added "+Utilities.HYDROGEN_NAME+" vertex for fixing mass balance\n");
			}
			// add hydrogen molecule(s) on the adequate side
			if (hydrogenImbalance < 0) {
				DefaultWeightedEdge edge = getEdge(hydrogen, reaction);
				if (edge == null) {
					edge = addEdge(hydrogen, reaction);
					setEdgeWeight(edge, -hydrogenImbalance);
				} else
					setEdgeWeight(edge, getEdgeWeight(edge)-hydrogenImbalance);
			} else {
				DefaultWeightedEdge edge = getEdge(reaction, hydrogen);
				if (edge == null) {
					edge = addEdge(reaction, hydrogen);
					setEdgeWeight(edge, hydrogenImbalance);
				} else
					setEdgeWeight(edge, getEdgeWeight(edge)+hydrogenImbalance);				
			}
			
			String message = "Fixed reaction "+reaction.getName()+" by adding "+Math.abs(hydrogenImbalance)+" "+hydrogen.getName()+" molecules on the "+(hydrogenImbalance<0?"left":"right")+" side"+(this.compartments?", compartment "+hydrogen.getCompartment():"")+".";
			if (getCompartments(reaction).size() > 1)
				message += " Reaction in more than one compartment.";
			infoWriter.write(message+"\n");
			if (debug)
				System.out.println(message);
		}
		
		if (debug) {
			// check if we did everything right
			int[] check = balance(reaction);
			for (int i=0; i<check.length; i++)
				if (check[i] != 0)
					throw new RuntimeException("Reaction "+reaction.getName()+" not balanced in "+Utilities.ELEMENTS[i]+" ("+check[i]+").");
		}
		
		return added;
	}
	
	/*********************
	 * Graph properties. *
	 *********************/
	
	/**
	 * Exports the sparse adjacency matrix of the graph into a tab-separated file.
	 * Upper-left and lower-right sub-matrices contain only zeroes because the graph
	 * is bipartite.
	 * 
	 * Time: O(m*n).
	 * 
	 * TODO validate before using this method
	 * TODO reversed reactions are not considered
	 * 
	 * @param file
	 * @throws IOException
	 */
	@Deprecated
	public void adjacencyMatrix(String file) throws IOException {
		BufferedWriter writer = new BufferedWriter(new FileWriter(file));
		int numberOfReactions = 0;
		boolean first = true;
		
		for (Iterator<Vertex> compounds = getCompounds().iterator(); compounds.hasNext();) {
			Vertex compound = compounds.next();
			// compound-compound sub-matrix is all zeroes
			for (int i=0; i<getCompounds().size(); i++)
				writer.write("0\t");
			
			// compound-reaction sub-matrix contains the substrates
			for (Iterator<Vertex> reactions = getReactions().iterator(); reactions.hasNext();) {
				Vertex reaction = reactions.next();
				int weight = 0;
				DefaultWeightedEdge substrateEdge = getEdge(compound, reaction);
				if (substrateEdge != null)
					weight = (int)getEdgeWeight(substrateEdge);
				writer.write(String.valueOf(weight));
				if (reactions.hasNext())
					writer.write("\t");
				if (first)
					numberOfReactions++;
			}
			first = false;
			writer.write("\n");
		}
		
		for (Iterator<Vertex> reactions = getReactions().iterator(); reactions.hasNext();) {
			Vertex reaction = reactions.next();
			
			// reaction-compound sub-matrix contains the products
			for (Iterator<Vertex> compounds = getCompounds().iterator(); compounds.hasNext();) {
				int weight = 0;
				Vertex compound = compounds.next();
				DefaultWeightedEdge productEdge = getEdge(reaction, compound);
				if (productEdge != null)
					weight = (int)getEdgeWeight(productEdge);
				writer.write(String.valueOf(weight)+"\t");
			}
			
			// reaction-reaction sub-matrix is all zeroes
			for (int i=0; i<numberOfReactions; i++) {
				writer.write("0");
				if (i<numberOfReactions-1)
					writer.write("\t");	
			}
			
			if (reactions.hasNext())
				writer.write("\n");
		}
		
		writer.close();
	}
	
	/**
	 * Exports the sparse stoichiometric matrix of the graph into a tab-separated file.
	 * Note that coefficients are summed if a substrate is as well a product of a reaction.
	 * If reversible==true, then reversible reactions are represented by two columns, one
	 * for each direction of the reaction. Otherwise, only the 'forward' direction is represented
	 * as a column, and the reversible reaction names and indices are printed to the log-file.
	 * If labelled==true initial column and row labels containing the reaction and compound
	 * names are printed, otherwise the reactions and compounds are ordered lexicographically. 
	 * 
	 * Time: O(m*n).
	 * 
	 * @param file
	 * @param reversible
	 * @param labelled
	 * @param sorted
	 * @param log
	 * @throws IOException
	 */
	public void stoichiometricMatrix(String file, boolean reversible, boolean labelled, boolean sorted, boolean log) throws IOException {
		BufferedWriter writer = new BufferedWriter(new FileWriter(file));
		BufferedWriter infoWriter = null;
		if (log)
			infoWriter = new BufferedWriter(new FileWriter(file+".log"));
		
		Collection<Vertex> reactionsSet = getReactions();
		Collection<Vertex> compoundsSet = new HashSet<Vertex>(getCompounds().size());
		
		// remove external metabolites (required for FBA)
		for (Vertex compound : getCompounds()) {
			// include hydrogen and biomass (as done by Grafahrend-Belau et al. 2008)
//			if (!"ex".equals(compound.getCompartment()) || compound.getName().equals("H") || compound.getName().equals("biomass"))
			compoundsSet.add(compound);
		}
		
		if (sorted) {
			// sort the compounds by name and compartment
			ArrayList<Vertex> compoundsList = new ArrayList<Vertex>(compoundsSet);
	    	Collections.sort(compoundsList, new VertexComparator());
			// sort the reactions by name and reversedness
	    	ArrayList<Vertex> reactionsList = new ArrayList<Vertex>(reactionsSet);
	    	Collections.sort(reactionsList, new VertexComparator());
	    	// assign the sorted sets to the collection
	    	compoundsSet = compoundsList;
	    	reactionsSet = reactionsList;
	    	if (log) {
		    	// log the ordered labels
		    	infoWriter.write("Compounds (rows): ");
		    	for (Iterator<Vertex> compounds = compoundsSet.iterator(); compounds.hasNext();) {
		    		Vertex compound = compounds.next();
		    		infoWriter.write(compound.getName()+(compound.getCompartment()!=null ? Utilities.DELIMITER_COMPOUND_COMPARTMENT+compound.getCompartment() : ""));
		    		if (compounds.hasNext())
		    			infoWriter.write("\t");
		    	}
		    	infoWriter.write("\nReactions (cols): ");
		    	for (Iterator<Vertex> reactions = reactionsSet.iterator(); reactions.hasNext();) {
		    		Vertex reaction = reactions.next();
		    		infoWriter.write(reaction.getName());
		    		if (reversible && reaction.reversedReaction() != null)
		    			infoWriter.write("\t"+reaction.reversedReaction().getName()+"$rev");
		    		if (reactions.hasNext())
		    			infoWriter.write("\t");
		    	}
		    	infoWriter.write("\n");
	    	}
		}
		
		if (log && !reversible) {
			// if reversible reactions are only printed as one direction, then print the reversible reaction names and indices
			ArrayList<String> reversibleNames = new ArrayList<String>(reactions.size());
			ArrayList<Integer> reversibleIndices = new ArrayList<Integer>(reactions.size());
			int i = 0;
			for (Iterator<Vertex> reactions = reactionsSet.iterator(); reactions.hasNext(); i++) {
				Vertex reaction = reactions.next();
				if (reaction.reversedReaction() != null) {
					reversibleNames.add(reaction.getName());
					reversibleIndices.add(i);
				}
			}
			infoWriter.write("Reversible: ");
			for (int j=0; j<reversibleNames.size(); j++) {
				infoWriter.write(reversibleNames.get(j));
				infoWriter.write(j<reversibleNames.size()-1 ? "\t" : "\n");
			}
			infoWriter.write("Reversible indices: ");
			for (int j=0; j<reversibleIndices.size(); j++) {
				infoWriter.write(String.valueOf(reversibleIndices.get(j)));
				infoWriter.write(j<reversibleIndices.size()-1 ? "\t" : "\n");
			}
		}
		
		if (labelled) {
			// print the label row
			writer.write("\t");
			for (Iterator<Vertex> reactions = reactionsSet.iterator(); reactions.hasNext();) {
				Vertex reaction = reactions.next();
				writer.write(reaction.getName());
				if (reversible && reaction.reversedReaction() != null)
					writer.write("\t"+reaction.reversedReaction().getName()+"$rev");
				if (reactions.hasNext())
					writer.write("\t");
			}
			writer.write("\n");
		}
		
		// print the compound rows
		for (Iterator<Vertex> compounds = compoundsSet.iterator(); compounds.hasNext();) {
			Vertex compound = compounds.next();
			
			if (labelled) {
				String name = compound.getName()+(compound.getCompartment()!=null ? Utilities.DELIMITER_COMPOUND_COMPARTMENT+compound.getCompartment() : "");
				writer.write(name+"\t");
			}
			
			// print the matrix entries (reaction columns)
			for (Iterator<Vertex> reactions = reactionsSet.iterator(); reactions.hasNext();) {
				Vertex reaction = reactions.next();
				int weight = 0;
				DefaultWeightedEdge substrateEdge = getEdge(compound, reaction);
				DefaultWeightedEdge productEdge = getEdge(reaction, compound);
				
				if (substrateEdge != null)
					weight = -(int)getEdgeWeight(substrateEdge);
				if (productEdge != null)
					weight += (int)getEdgeWeight(productEdge);
				if (log && substrateEdge != null && productEdge != null)
					infoWriter.write("Reaction "+reaction.getName()+" contains "+compound.getName()+" on both sides. Summed coefficient is "+weight+".\n");
				
				writer.write(String.valueOf(weight));
				if (reversible && reaction.reversedReaction() != null)
					writer.write("\t"+String.valueOf(-weight));
				if (reactions.hasNext())
					writer.write("\t");
			}
			
			writer.write("\n");
		}
		
		writer.close();
		if (log)
			infoWriter.close();
	}
	
	/**
	 * Prints a m x n matrix containing the mass vectors of the compounds in the network,
	 * where m is the number of compounds, and n the number of considered atomic elements
	 * (specified as ELEMENTS in the configuration file).
	 * 
	 * @param outputFile The output file to write to.
	 * @param labelled If labelled==true, an additional header row and column are printed
	 * containing the names of atomic elements, respectively compound names. 
	 * @throws IOException
	 */
	public void massMatrix(String outputFile, boolean labelled) throws IOException {
		BufferedWriter matrixWriter = new BufferedWriter(new FileWriter(outputFile));
		
		Collection<Vertex> reactionsSet = getReactions();
		Collection<Vertex> compoundsSet = getCompounds();
		
		// sort the compounds by name and compartment
		ArrayList<Vertex> compoundsList = new ArrayList<Vertex>(compoundsSet);
		Collections.sort(compoundsList, new VertexComparator());
		// sort the reactions by name (and implicitly by reversedness)
		ArrayList<Vertex> reactionsList = new ArrayList<Vertex>(reactionsSet);
		Collections.sort(reactionsList, new VertexComparator());
		
		if (labelled) {
			// print a header row containing the names of atomic elements
			matrixWriter.write("\t");
			for (int i=0; i<Utilities.ELEMENTS.length; i++) {
				matrixWriter.write(Utilities.ELEMENTS[i]);
				if (i < Utilities.ELEMENTS.length-1)
					matrixWriter.write("\t");
				else
					matrixWriter.write("\n");
			}
		}
		
		for (Vertex compound : compoundsList) {
			if (labelled) {
				// print a header column containing the names of compounds
				matrixWriter.write(compound.getName()+(hasCompartments() ? Utilities.DELIMITER_COMPOUND_COMPARTMENT+compound.getCompartment() : "")+"\t");
			}
			// print the atomic mass elements
			int[] mass = compound.getMass();
			for (int i=0; i<Utilities.ELEMENTS.length; i++) {
				matrixWriter.write(mass == null ? "NA" : String.valueOf(mass[i]));
				if (i < Utilities.ELEMENTS.length-1)
					matrixWriter.write("\t");
				else
					matrixWriter.write("\n");
			}
		}
		
		matrixWriter.close();
	}

	/**
	 * Determines the average reaction degree, i.e., the average of the 
	 * in-degrees plus the out-degrees.
	 * 
	 * @return Average reaction degree.
	 */
	public BigDecimal averageReactionDegree() {
		int degrees = 0;
		
		for (Iterator<Vertex> reactions = getReactions().iterator(); reactions.hasNext();) {
			Vertex reaction = reactions.next();
			int inDegree = inDegreeOf(reaction);
			int outDegree = outDegreeOf(reaction);
			degrees += inDegree + outDegree;
		}
		
		BigDecimal avgDegree = new BigDecimal(String.valueOf(degrees)).divide(new BigDecimal(String.valueOf(getReactions().size())), MathContext.DECIMAL32);
		return avgDegree;
	}
	
	/**
	 * Returns the maximum in-degree of a reaction in the network.
	 * @return Maximum in-degree.
	 */
	public int maxReactionInDegree() {
		
		int maxDegree = -1;
		for (Iterator<Vertex> reactions = getReactions().iterator(); reactions.hasNext();) {
			int degree = inDegreeOf(reactions.next());
			if (degree > maxDegree)
				maxDegree = degree;
		}
		return maxDegree;
	}
	
	/**
	 * Returns the maximum out-degree of a reaction in the network.
	 * @return Maximum out-degree.
	 */
	public int maxReactionOutDegree() {
		
		int maxDegree = -1;
		for (Iterator<Vertex> reactions = getReactions().iterator(); reactions.hasNext();) {
			int degree = outDegreeOf(reactions.next());
			if (degree > maxDegree)
				maxDegree = degree;
		}
		return maxDegree;
	}
	
	/**
	 * Returns the maximum undirected degree of a reaction in the network.
	 * @return Maximum in-degree.
	 */
	public int maxReactionDegree() {
		
		int maxDegree = -1;
		for (Vertex reaction : getReactions()) {
			int degree = inDegreeOf(reaction)+outDegreeOf(reaction);
			if (degree > maxDegree) {
				maxDegree = degree;
			}
		}
		return maxDegree;
	}
	
	/**
	 * Prints a tab-separated list of compound degrees. The degree of a compound is
	 * the number of reactions it takes part in, not including reversed reactions.
	 * 
	 * NOTE: do not run this method from parallel processes writing to the same output file, as the
	 * files remain open during method execution.
	 * 
	 * @param file
	 * @param append
	 * @throws IOException
	 */
	public void compoundDegrees(String file, boolean append) throws IOException {
		BufferedWriter writer = new BufferedWriter(new FileWriter(file, append));
		
		for (Iterator<Vertex> compounds = getCompounds().iterator(); compounds.hasNext();) {
			Vertex compound = compounds.next();
			
			if (this.reversible)
				// if all reactions are reversible the degree is half the number of neighbour reactions
				writer.write(String.valueOf((inDegreeOf(compound)+outDegreeOf(compound))/2));
			else {
				// count the non-reversed reactions
				int degree = 0;
				for (Vertex reaction : Graphs.predecessorListOf(this, compound))
					if (!reaction.isReversed())
						degree++;
				for (Vertex reaction : Graphs.successorListOf(this, compound))
					if (!reaction.isReversed())
						degree++;
				writer.write(String.valueOf(degree));
			}
			if (compounds.hasNext())
				writer.write("\t");
		}
		writer.write("\n");
		writer.close();
	}
	
	/**
	 * Prints the dead-end compounds to a file. Dead-ends are compounds which have either
	 * an in-degree or out-degree of 0. Note that reversibility is considered, such that
	 * compounds only occurring in transport reactions (e.g. A->A) are only dead-ends if
	 * the reaction is irreversible.  
	 * 
	 * @param outputFile
	 * @return Number of dead-end compounds.
	 * @throws IOException
	 */
	public int compoundDeadEnds(String outputFile) throws IOException {
		BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile, false));
		int deadEnds = 0;
		
		for (Vertex compound : getCompounds()) {
			if (inDegreeOf(compound) == 0  || outDegreeOf(compound) == 0) {
				deadEnds++;
				writer.write(compound.getName()+"\t");
				for (Vertex reaction : Graphs.predecessorListOf(this, compound))
					writer.write(reaction.getName()+"\t");
				for (Vertex reaction : Graphs.successorListOf(this, compound))
					writer.write(reaction.getName()+"\t");
				writer.write("\n");
			}
		}
		
		writer.close();
		return deadEnds;
	}
	
	/**
	 * Prints a tab-separated list of reaction in-degrees and reaction out-degrees.
	 * 
	 * NOTE: do not run this method from parallel processes writing to the same output file, as the
	 * files remain open during method execution.
	 * 
	 * @param file
	 * @param append
	 * @throws IOException
	 */
	public void reactionDegrees(String file, boolean append) throws IOException {
		BufferedWriter inWriter = new BufferedWriter(new FileWriter(file+".in", append));
		BufferedWriter outWriter = new BufferedWriter(new FileWriter(file+".out", append));
		
		for (Iterator<Vertex> reactionIt = getReactions().iterator(); reactionIt.hasNext();) {
			Vertex reaction = reactionIt.next();
			inWriter.write(String.valueOf(inDegreeOf(reaction)));
			outWriter.write(String.valueOf(outDegreeOf(reaction)));
			if (reactionIt.hasNext()) {
				inWriter.write("\t");
				outWriter.write("\t");
			}
		}
		
		inWriter.write("\n");
		outWriter.write("\n");
		
		inWriter.close();
		outWriter.close();
	}
	
	/**
	 * Prints a tab-separated list of compound in- or out-degrees. The in-/out-degree of a compound
	 * is the number of reactions it takes part in as a product/substrate, including reversed reactions.
	 * 
	 * NOTE: do not run this method from parallel processes writing to the same output file, as the
	 * files remain open during method execution.
	 * 
	 * @param file
	 * @param append
	 * @throws IOException
	 */
	public void compoundInOutDegrees(String file, boolean in, boolean append) throws IOException {
		BufferedWriter writer = new BufferedWriter(new FileWriter(file, append));
		
		if (this.reversible)
			throw new RuntimeException("This method doesn't make sense for reversible graphs.");
		
		for (Iterator<Vertex> compounds = getCompounds().iterator(); compounds.hasNext();) {
			Vertex compound = compounds.next();
			
			// NOTE: if the graph is reversible the in- and out-degrees are equal 
			if (in)
				writer.write(String.valueOf((inDegreeOf(compound))));
			else
				writer.write(String.valueOf((outDegreeOf(compound))));
			if (compounds.hasNext())
				writer.write("\t");
		}
		writer.write("\n");
		writer.close();
	}
	
	/**
	 * Prints the edge weights of the graph into a tab-separated file.
	 * Reversed reactions are omitted (they have the same weights as
	 * the corresponding forward reaction).
	 * 
	 * NOTE: do not run this method from parallel processes writing to the same output file, as the
	 * files remain open during method execution.
	 * 
	 * @param file
	 * @throws IOException
	 */
	public void weights(String file, boolean append) throws IOException {
		BufferedWriter writer = new BufferedWriter(new FileWriter(file, append));
		
		int numberOfEdges = reversible ? edgeSet().size()/2 : edgeSet().size();
		
		int counter = 0;
		for (Iterator<DefaultWeightedEdge> it = edgeSet().iterator(); it.hasNext(); ) {
			DefaultWeightedEdge edge = it.next();
			// print weights only for forward reactions
			Vertex reaction = (getEdgeSource(edge).getType() == Vertex.REACTION ? getEdgeSource(edge) : getEdgeTarget(edge));
			if (!reaction.isReversed()) {
				writer.write(String.valueOf((int)getEdgeWeight(edge)));
				if (counter < numberOfEdges-1)
					writer.write("\t");
				counter++;
			}
		}
		writer.write("\n");
		writer.close();
	}
	
	/**
	 * Determines the undirected clustering coefficient in the corresponding
	 * metabolite-metabolite network, i.e., the clustering coefficient in
	 * the mm-network, where all edges are considered undirected. Note that
	 * edge directions are considered in the metabolite-reaction network,
	 * such that the neighbours of a compound are all compounds occurring on the
	 * opposite side of a reaction.    
	 * 
	 * The local clustering coefficient of compounds with less than
	 * two neighbours is 0.
	 * 
	 * NOTE: the result is (slightly) imprecise due to floating point representations.
	 * 
	 * @return Clustering coefficient.
	 */
	public double clusteringCoefficientUndirected() {
		boolean debug = false;
		double clusteringCoefficient = 0;
		
		for (Vertex compound : getCompounds()) {
			int connections = 0;
			
			if (debug)
				System.out.println("Compound: "+compound.getName());
			
			// count the substrate-product connections between the successors
			ArrayList<Vertex> neighbours = new ArrayList<Vertex>();
			for (Vertex reaction : Graphs.successorListOf(this, compound)) {
				for (Vertex neighbour : Graphs.successorListOf(this, reaction)) {
					if (!neighbours.contains(neighbour)) {
						for (Vertex previous : neighbours) {
							if (isNeighbour(neighbour, previous)) {
								connections++;
								if (debug)
									System.out.println(neighbour.getName()+" <---> "+previous.getName()+"; ");
							}
						}
						neighbours.add(neighbour);
					}
				}
			}
			
			// count the substrate-product connections between the predecessors
			for (Vertex reaction : Graphs.predecessorListOf(this, compound)) {
				for (Vertex neighbour : Graphs.predecessorListOf(this, reaction)) {
					if (!neighbours.contains(neighbour)) {
						for (Vertex previous : neighbours) {
							if (isNeighbour(neighbour, previous)) {
								connections++;
								if (debug)
									System.out.println(neighbour.getName()+" <---> "+previous.getName()+"; ");
							}
						}
						neighbours.add(neighbour);
					}
				}
			}
			
			// add the clustering coefficient for this compound
			if (neighbours.size() > 1)
				clusteringCoefficient += (double)(2*connections)/(double)((neighbours.size()*(neighbours.size()-1)));
			
			if (debug) {
				System.out.println();
				System.out.println(neighbours.size()+" neighbours, "+connections+" connections, "+(neighbours.size()*(neighbours.size()-1))/2+" possible connections.");
				System.out.println("Clustering coefficient: "+((neighbours.size() > 1) ? (double)(2*connections)/(double)((neighbours.size()*(neighbours.size()-1))) : 0));
				System.out.println();
			}
		}
		
		if (debug)
			System.out.println("Average clustering coefficient: "+clusteringCoefficient/(double)getCompounds().size());
		
		// return the average clustering coefficient
		return clusteringCoefficient/(double)getCompounds().size();
	}
	
	/**
	 * Tests if the two compounds are neighbours, i.e., if they are connected
	 * by a substrate-product or product-substrate relationship.
	 *  
	 * @param v1
	 * @param v2
	 * @return true, if v1 and v2 are neighbours.
	 */
	public boolean isNeighbour(Vertex v1, Vertex v2) {
		return isAdjacent(v1,v2) || isAdjacent(v2, v1);
	}
	
	/**
	 * Tests if compound c1 is adjacent to compound c2, i.e., if there is a reaction which
	 * has c1 as a substrate and c2 as a product.
	 *  
	 * @param c1
	 * @param c2
	 * @return true, if c1 and c2 are adjacent, false otherwise.
	 */
	public boolean isAdjacent(Vertex c1, Vertex c2) {
		if (c1.getType() == Vertex.REACTION || c2.getType() == Vertex.REACTION)
			throw new IllegalArgumentException("Method not implemented for reactions.");
		
		// check the substrate-product connection
		// traversing outgoing edges is faster than successorListOf
		for (DefaultWeightedEdge edge1 : outgoingEdgesOf(c1)) {
			for (DefaultWeightedEdge edge2 : outgoingEdgesOf(getEdgeTarget(edge1))) {
				if (getEdgeTarget(edge2).equals(c2))
					return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Test if compound c2 is reachable from compound c1, i.e.,
	 * if there exists a directed path from c1 to c2.
	 * 
	 * First call should pass an empty HashSet of visited compounds. 
	 * 
	 * @param c1
	 * @param c2
	 * @param visited
	 * @return true, if c2 is reachable from c1, false otherwise.
	 */
	public boolean isReachable(Vertex c1, Vertex c2, HashSet<Vertex> visited) {
		
		if (isAdjacent(c1, c2)) {
			return true;
		} else {
			for (DefaultWeightedEdge substrateEdge : outgoingEdgesOf(c1)) {
				for (DefaultWeightedEdge productEdge : outgoingEdgesOf(getEdgeTarget(substrateEdge))) {
					c1 = getEdgeTarget(productEdge);
					if (!visited.contains(c1)) {
						visited.add(c1);
						return isReachable(c1, c2, visited);
					}
				}
			}
			return false;
		}
	}
	
	/**
	 * Tests whether the given compounds are connected via paths with the given
	 * reversibilities. If reversible is true at index i, then the compounds i
	 * and i+1 must be connected via directed paths in both directions.
	 * 
	 * @param compounds
	 * @param compartments
	 * @param reversible
	 * @return boolean[] of length compounds.length-1, true at index i, if a path
	 * exists between compound i and compound i+1, false otherwise.
	 */
	public boolean[] isConnected(ArrayList<String> compounds, ArrayList<String> compartments, ArrayList<Boolean> reversible) {
		
		if (compounds.size() != compartments.size())
			throw new IllegalArgumentException("Unequal numer of compounds and compartments.");
		if (compounds.size() != reversible.size()+1)
			throw new IllegalArgumentException("Number of reversibilities unequals number of paths (number of compounds-1).");
		
		boolean[] paths = new boolean[compounds.size()-1];
		
		for (int i=0; i<compounds.size()-1; i++) {
			Vertex from = getCompound(compounds.get(i), compartments.get(i));
			Vertex to = getCompound(compounds.get(i+1), compartments.get(i+1));
			
			// check if the network contains the specified compounds
			if (from == null || to == null) {
				System.out.println("Compound "+(from==null?compounds.get(i):compounds.get(i+1))+" in compartment "+(from==null?compartments.get(i):compartments.get(i+1))+" not found in network.");
				return new boolean[compounds.size()-1];
			}
			
			paths[i] = isReachable(from, to, new HashSet<Vertex>());
			if (reversible.get(i))
				paths[i] = (paths[i] && isReachable(to, from, new HashSet<Vertex>()));
		}
		
		return paths;
	}
	
	/**
	 * Checks if the given intermediary compounds are adjacent in any compartment.
	 * If bothDirections==true, then the compounds must be adjacent in both
	 * directions.
	 *  
	 * @param compounds Intermediary compounds to check for connections.
	 * @return true, if the path exists, false otherwise.
	 */
	public boolean isPath(ArrayList<String> compounds, boolean bothDirections) {
		
		for (String compartment : getCompartments().keySet()) {
			boolean forward = true, backward = bothDirections;
			
			for (int i=0; i<compounds.size()-1; i++) {
				Vertex from = getCompound(compounds.get(i), compartment);
				Vertex to = getCompound(compounds.get(i+1), compartment);
				// check if the compartment contains the specified compounds
				if (from == null || to == null) {
					forward = false;
					backward = false;
				}
				if (forward && !isAdjacent(from, to))
					forward = false;
				if (backward && !isAdjacent(to, from))
					backward = false;
				if (!forward && !backward)
					break;
			}
			
			if (forward || backward)
				return true;
		}
		
		return false;
	}

	/**
	 * Determines whether the given reaction is a cyclic reaction,
	 * i.e., the substrates and products are identical and have equal weights.
	 * 
	 * @param reaction
	 * @param print
	 * @return true, if the reaction is cyclic, false otherwise.
	 */
	public boolean isCyclic(Vertex reaction, boolean print) {
		if (!reaction.getType() == Vertex.REACTION)
			throw new IllegalArgumentException("Method can only be invoked on vertices of type Vertex.REACTION");
		
		int inDegree = inDegreeOf(reaction);
		int outDegree = outDegreeOf(reaction);
		if (inDegree == 0 || outDegree == 0 || inDegree != outDegree)
			return false;
		
		for (Vertex substrate : Graphs.predecessorListOf(this, reaction)) {
			double weight = getEdgeWeight(getEdge(substrate, reaction));
			if (!containsEdge(reaction, substrate) || getEdgeWeight(getEdge(reaction, substrate)) != weight)
				return false;
		}
		
		if (print)
			System.out.println("Cyclic reaction: "+reaction.getName());
		return true;
	}
	
	/**
	 * Determines whether the given reaction has a cycle,
	 * i.e., there is a substrates which is also a product.
	 * 
	 * @param reaction
	 * @return true, if the reaction has a cycle, false otherwise.
	 */
	public boolean hasCycle(Vertex reaction) {
		if (!reaction.getType() == Vertex.REACTION)
			throw new IllegalArgumentException("Method can only be invoked on vertices of type Vertex.REACTION");
		
		if (inDegreeOf(reaction) == 0 || outDegreeOf(reaction) == 0)
			return false;
		
		for (Vertex substrate : Graphs.predecessorListOf(this, reaction)) {
			if (containsEdge(reaction, substrate))
				return true;
		}
		
		return false;
	}
	
	/**
	 * Returns the map of compartment strings and the substrates/products of the reaction which belong to
	 * the compartment.
	 * If the size of the key set is greater than 1, than the reaction is involved in a compartment transport.
	 * 
	 * @param reaction
	 * @return HashMap of compartment strings and their substrates/products.
	 */
	public HashMap<String,HashSet<Vertex>> getCompartments(Vertex reaction) {
		HashMap<String,HashSet<Vertex>> compartments = new HashMap<String,HashSet<Vertex>>(this.inDegreeOf(reaction)+this.outDegreeOf(reaction)); 
		
		if (!reaction.getType() == Vertex.REACTION)
			throw new IllegalArgumentException("Method can only be invoked on vertices of type Vertex.REACTION");
		
		for (Vertex substrate : Graphs.predecessorListOf(this, reaction)) {
			String compartment = substrate.getCompartment();
			if (!compartments.containsKey(compartment))
				compartments.put(compartment, new HashSet<Vertex>());
			else
				compartments.get(compartment).add(substrate);
		}
		for (Vertex product : Graphs.successorListOf(this, reaction)) {
			String compartment = product.getCompartment();
			if (!compartments.containsKey(compartment))
				compartments.put(compartment, new HashSet<Vertex>());
			else
				compartments.get(compartment).add(product);			
		}
		
		return compartments;
	}
	
	/**
	 * Given a set of strongly connected components, returns the number of n-cycles.
	 * Algorithm by Liu, Wang (2006).
	 * 
	 * Note that this implementation includes reversible reactions, e.g. as 2-cycles.
	 * 
	 * @param components
	 * @param n
	 * @param printCycles
	 * @param printComponents
	 * @return Number of n-cycles.
	 */
	public int cycleCount(List<Set<Vertex>> components, int n, boolean printCycles, boolean printComponents) {
		boolean debug = false;
		int cycleCount = 0;
		ArrayList<Integer> sizes = new ArrayList<Integer>();
		
		if (n < 2)
			throw new IllegalArgumentException("Cycle length must be at least 2.");
		
		if (debug)
			System.out.println("Counting "+n+"-cycles:");
		
		// determine the cycles on every strongly connected component
		for (Iterator<Set<Vertex>> componentIt = components.iterator(); componentIt.hasNext();) {
			Set<Vertex> component = componentIt.next();
			ArrayList<ArrayList<Vertex>> queue = new ArrayList<ArrayList<Vertex>>();
			
			// put the compounds into the queue as paths of length 1
			for (Iterator<Vertex> vertexIt = component.iterator(); vertexIt.hasNext();) {
				Vertex compound = vertexIt.next(); 
				if (compound.getType() == Vertex.COMPOUND) {
					ArrayList<Vertex> path = new ArrayList<Vertex>();
					path.add(compound);
					queue.add(path);
					if (debug) {
						for (Vertex c : path) {
							System.out.print(c.getName()+"; ");
						}
						System.out.println();
					}
				}
			}
			
			if (printComponents)
				sizes.add(queue.size());
			
			// skip search if the component has less compounds than the cycle length
			if (queue.size() >= n) {
				
				while (queue.size() > 0 && queue.get(0).size() <= n) {
					// pop the first element (FIFO)
					ArrayList<Vertex> path = queue.remove(0);
					int length = path.size();
					Vertex head = path.get(0);
					Vertex tail = path.get(path.size()-1);
					
					// collect successors
					HashSet<Vertex> successors = new HashSet<Vertex>();
					for (Vertex reaction : Graphs.successorListOf(this, tail))
						successors.addAll(Graphs.successorListOf(this, reaction));
						
					// check for n-cycles and add subsequent paths to the queue
					for (Vertex successor : successors) {
						// use hash code as arbitrary ordering in order to count each cycle exactly once
						if (head.hashCode() <= successor.hashCode() && ((length == n && head.equals(successor)) || !path.contains(successor))) {
							// check for n-cycle
							if (length == n && head.equals(successor)) {
								cycleCount++;
								if (debug) {
									for (int i=0; i<path.size(); i++) {
										System.out.print(path.get(i).getName()+Utilities.DELIMITER_COMPOUND_COMPARTMENT+path.get(i).getCompartment());
										if (i < path.size()-1)
											System.out.print(" ---> ");
									}
									System.out.println();
								}
							} else {
								ArrayList<Vertex> newPath = new ArrayList<Vertex>(path);
								newPath.add(successor);
								queue.add(newPath);
								newPath = null;
							}
						}
					}
					// free some memory
					successors = null;
				}
			}
		}
		
		if (printComponents) {
			Collections.sort(sizes);
			// print the sizes
			System.out.print(sizes.size()+" strongly connected components of sizes: ");
			for (int i=sizes.size()-1; i>=0; i--) {
				System.out.print(sizes.get(i)+" ");
				if (i > 2 && sizes.get(i) == 1) {
					System.out.print("... ("+i+" more).");
					break;
				}
			}
			System.out.println();
		}
		if (printCycles)
			System.out.println(cycleCount+" "+n+"-cycles.");
		
		return cycleCount;
	}
	
	/**
	 * Calculates random scopes for the given seed sizes and writes the scope sizes of each seed size
	 * to a separate file.
	 * 
	 * The output file names are created by appending the seed size to the given file name.
	 * 
	 * NOTE: do not run this method from parallel processes writing to the same output file, as the
	 * files remain open during method execution.
	 * 
	 * @param seedSizes
	 * @param scopeFile
	 * @param scopeFile2
	 * @param append
	 * @throws IOException
	 */
	public void randomScopeSizes(int[] seedSizes, String scopeFile, String scopeFile2, boolean append) throws IOException {
		boolean performance = false;
		boolean debug = false;
		
		Random random = new Random();
		
		long start = 0, time = 0, oldTime = 0;
		int iterations = 5000;
		
		Vertex[] compounds = new Vertex[getCompounds().size()];
		getCompounds().toArray(compounds);
		
		for (int i=0; i<seedSizes.length; i++) {
			
			if (seedSizes[i] > getCompounds().size())
				throw new IllegalArgumentException("Seed size "+seedSizes[i]+" larger than number of compounds ("+getCompounds().size()+").");
			
			HashSet<Vertex> seed = new HashSet<Vertex>(seedSizes[i], 1f);
			BufferedWriter scopeWriter = new BufferedWriter(new FileWriter(scopeFile+seedSizes[i], append));
			BufferedWriter scopeWriter2 = null;
			if (scopeFile2 != null)
				scopeWriter2 = new BufferedWriter(new FileWriter(scopeFile2+seedSizes[i], append));
			
			for (int j=0; j<iterations; j++) {
				
				// select random compounds as seed
				while (seed.size() < seedSizes[i]) {
					seed.add(compounds[random.nextInt(compounds.length)]);
				}

				if (debug) {
					System.out.println();
					System.out.print("Seed ("+seed.size()+"): ");
					for (Iterator<Vertex> seedIt = seed.iterator(); seedIt.hasNext();)
						System.out.print(seedIt.next().getName()+"; ");
					System.out.println();
				}
				
				if (performance) {
					
					Set<Vertex> scope = null;
					Set<Vertex> scope_old = null;
					
					// change order of execution: the second is faster
					if (j%2 == 0) {
						// new method first					
						start = System.currentTimeMillis();
						scope = scope(seed);
						time += System.currentTimeMillis()-start;
						// old method
						start = System.currentTimeMillis();
						scope_old = scope_old(seed);
						oldTime += System.currentTimeMillis()-start;
					} else {
						// old method first
						start = System.currentTimeMillis();
						scope_old = scope_old(seed);
						oldTime += System.currentTimeMillis()-start;
						// new method					
						start = System.currentTimeMillis();
						scope = scope(seed);
						time += System.currentTimeMillis()-start;
					}
					
					if (!scope_old.equals(scope))
						throw new RuntimeException("Scopes unequal.");
				}
				
				String scopeSize = String.valueOf(scope(seed).size());
				scopeWriter.write(scopeSize);
				if (scopeWriter2 != null)
					scopeWriter2.write(scopeSize);
				
				if (j<iterations-1) {
					scopeWriter.write("\t");
					if (scopeWriter2 != null)
						scopeWriter2.write("\t");
				}
				
				seed.clear();
			}
			
			scopeWriter.write("\n");
			scopeWriter.close();
			if (scopeWriter2 != null) {
				scopeWriter2.write("\n");
				scopeWriter2.close();
			}
		}
		
		if (performance) {
			System.out.println();
			System.out.println("New scopes time: "+time+" ms");
			System.out.println("Old scopes time: "+oldTime+" ms");
		}
	}
	
	/**
	 * Returns the scope for the given set of seed compounds.
	 * 
	 */
	public Set<Vertex> scope(Set<Vertex> seed) {
		boolean added = true;
		// different initial hash sizes have no significant performance effect
		// using a hash map for adjacent vertices has no performance effect on Linux with -server option
		int seedSize = seed.size();
		HashSet<Vertex> scope = new HashSet<Vertex>(5*seedSize, 0.75f);
		HashSet<Vertex> visited = new HashSet<Vertex>(5*seedSize, 0.75f);
		HashSet<Vertex> tempSeed = new HashSet<Vertex>(3*seedSize, 0.75f);
		// copying the set gives a speedup, due to optimized initial size?
		seed = new HashSet<Vertex>(seed);
		
		// repeat until no more compounds are added
		while (added) {
			added = false;
			
			// iterate over the seed compounds
			for (Iterator<Vertex> seedIterator = seed.iterator(); seedIterator.hasNext();) {
				// iterate over the reactions reachable from the seed
				for (Iterator<DefaultWeightedEdge> reachableIterator = outgoingEdgesOf(seedIterator.next()).iterator(); reachableIterator.hasNext();) {
					Vertex reaction = getEdgeTarget(reachableIterator.next());
					if (!visited.contains(reaction) && !scope.contains(reaction)) {
						boolean producible = true;
						// determine whether the reachable reaction is producible by the seed
						for (Iterator<DefaultWeightedEdge> producibleIterator = incomingEdgesOf(reaction).iterator(); producibleIterator.hasNext();) {
							if (!seed.contains(getEdgeSource(producibleIterator.next()))) {
								producible = false;
								break;
							}
						}
						// add the producible compounds to the seed
						if (producible) {
							for (Iterator<DefaultWeightedEdge> producedIterator = outgoingEdgesOf(reaction).iterator(); producedIterator.hasNext();)
								tempSeed.add(getEdgeTarget(producedIterator.next()));
							scope.add(reaction);
						} else {
							visited.add(reaction);
						}
					}
				}
			}
			added = seed.addAll(tempSeed);
			visited.clear();
			tempSeed.clear();
		}
		
		return seed;
	}
	
	/**
	 * @deprecated
	 * @param seed
	 * @return The scope for the given set of seed compounds.
	 */
	public HashSet<Vertex> scope_old(HashSet<Vertex> seed) {
		boolean added = true; 
		// different initial hash sizes have no significant performance effect
		int seedSize = seed.size();
		HashSet<Vertex> scope = new HashSet<Vertex>(5*seedSize, 0.75f);
		HashSet<Vertex> visited = new HashSet<Vertex>(5*seedSize, 0.75f);
		HashSet<Vertex> tempSeed = new HashSet<Vertex>(3*seedSize, 0.75f);
		// copying the set gives a speedup, due to optimized initial size?
		seed = new HashSet<Vertex>(seed);
		
		// repeat until no more compounds are added
		while (added) {
			added = false;
			
			// iterate over the seed compounds
			for (Iterator<Vertex> seedIterator = seed.iterator(); seedIterator.hasNext();) {
				// iterate over the reactions reachable from the seed
				for (Iterator<DefaultWeightedEdge> reachableIterator = outgoingEdgesOf(seedIterator.next()).iterator(); reachableIterator.hasNext();) {
					Vertex reaction = getEdgeTarget(reachableIterator.next());
					if (!visited.contains(reaction) && !scope.contains(reaction)) {
						boolean producible = true;
						// determine whether the reachable reaction is producible by the seed
						for (Iterator<DefaultWeightedEdge> producibleIterator = incomingEdgesOf(reaction).iterator(); producibleIterator.hasNext();) {
							if (!seed.contains(getEdgeSource(producibleIterator.next()))) {
								producible = false;
								break;
							}
						}
						// add the producible compounds to the seed
						if (producible) {
							for (Iterator<DefaultWeightedEdge> producedIterator = outgoingEdgesOf(reaction).iterator(); producedIterator.hasNext();)
								tempSeed.add(getEdgeTarget(producedIterator.next()));
							scope.add(reaction);
						} else {
							visited.add(reaction);
						}
					}
				}
			}
			added = seed.addAll(tempSeed);
			visited.clear();
			tempSeed.clear();
		}
		
		return seed;
	}
	
	/**
	 * Determines the sizes of all connected components in the graph by expanding
	 * the transitive closure until every compound was visited. 
	 * 
	 * @return A sorted list containing the size of each connected component.
	 */
	public ArrayList<Integer> connectedComponents(boolean print) {
		boolean debug = false;
		ArrayList<Integer> sizes = new ArrayList<Integer>();
		HashSet<Vertex> visited = new HashSet<Vertex>(getCompounds().size());
		
		// iterate over all unvisited compounds (=components)
		for (Iterator<Vertex> compounds = getCompounds().iterator(); compounds.hasNext();) {
			Vertex compound = compounds.next();
			
			if (!visited.contains(compound)) {
				HashSet<Vertex> reachable = new HashSet<Vertex>();
				HashSet<Vertex> neighbours = new HashSet<Vertex>();
				reachable.add(compound);
			
				// iterate over all reachable, unvisited compounds, until all compounds are reached
				do {
					neighbours.clear();
					for (Iterator<Vertex> reachables = reachable.iterator(); reachables.hasNext();) {
						Vertex nextReachable = reachables.next();
						if (visited.add(nextReachable)) {
							// add all neighbouring compounds to neighbours
							for (Vertex reaction : Graphs.neighborListOf(this, nextReachable))
								neighbours.addAll(Graphs.neighborListOf(this, reaction));
						}
					}
				} while (reachable.addAll(neighbours));
				
				visited.addAll(neighbours);
				
				int componentSize = reachable.size();
				sizes.add(new Integer(componentSize));
				
				if (debug) {
					for (Vertex c : reachable) {
						System.out.print(c.getName()+"; ");
					}
					System.out.println();
				}
			}
		}
		
		if (print) {
			Collections.sort(sizes);
			// print the sizes
			System.out.print(sizes.size()+" connected components of sizes: ");
			for (int i=sizes.size()-1; i>=0; i--) {
				System.out.print(sizes.get(i)+" ");
				if (i > 2 && sizes.get(i) == 1) {
					System.out.print("... ("+i+" more).");
					break;
				}
			}
			System.out.println();
		}
		
		return sizes;
	}
	
	/**
	 * <p>
	 * Implementation of Floyd-Warshall's algorithm for computing all shortest paths in
	 * a directed graph. Adapted to calculate the average shortest path length. For reversible
	 * graphs the calculation could be faster by skipping the reverse path, but this
	 * implementation is already apx. 86 times faster than the naive algorithm.
	 * See <a href="http://algowiki.net/wiki/index.php/Floyd-Warshall%27s_algorithm" target="_blank">http://algowiki.net/wiki/index.php/Floyd-Warshall%27s_algorithm.</a>.
	 * 
	 * <p>
	 * NOTE: the result is (slightly) imprecise due to floating point representations.
	 * 
	 * @return Characteristic path length.
	 */
	public float characteristicPathLength() {
		int length = 0, numPaths = 0;
		int numCompounds = getCompounds().size();
		
		// create a vertex array from the hash map
		Vertex[] compounds = new Vertex[numCompounds];
		getCompounds().toArray(compounds);
		
		// initialize distances with Integer.MAX_VALUE
		int[][] distances = new int[numCompounds][numCompounds];
		for (int i=0; i<distances.length; i++)
			Arrays.fill(distances[i], Integer.MAX_VALUE);
		
		// set distances of the adjacent compounds to 1
		for (int i=0; i<numCompounds; i++)
			for (int j=0; j<numCompounds; j++)
				if (isAdjacent(compounds[i], compounds[j]))
					distances[i][j] = 1;
		
		// calculate the shortest path lengths
		for(int k=0; k<numCompounds; k++) {
			for(int i=0; i<numCompounds; i++) {
				for(int j=0; j<numCompounds; j++) {
					if (i != j && distances[i][k] != Integer.MAX_VALUE && distances[k][j] != Integer.MAX_VALUE && distances[i][k]+distances[k][j] < distances[i][j]) {
						distances[i][j] = distances[i][k] + distances[k][j];
					}
				}
			}
		}
		
		// calculate the average
		for(int i=0; i<numCompounds; i++) {
			for(int j=0; j<numCompounds; j++) {
				if (i != j && distances[i][j] < Integer.MAX_VALUE) {
					length += distances[i][j];
					numPaths++;
				}
			}
		}
		
		// the following operation may be (slightly) imprecise due to floating point representations
		return (float)length/(float)numPaths;
	}
	
	/**
	 * Calculates two assortativity coefficients on the directed MM-network: the pearson
	 * correlation coefficient of (1) the compound in-degrees and the average in-degrees of
	 * predecessors, (2) the compound out-degrees and the average out-degrees of successors.  
	 * 
	 * Note that, in contrast to Newman (Phys. Rev. E 67, 026126 (2003)) we use the actual
	 * degree instead of the excess degree (degree-1).
	 * 
	 * @return double[] of size 2 containing the in-degree/in-degree correlation coefficient
	 * at index 0, and the out-degree/out-degree correlation coefficient at index 1.
	 */
	public double[] assortativities() {
		boolean debug = false;
		double[] assortativities = new double[4];
		int[] inDeg = new int[getCompounds().size()];
		int[] outDeg = new int[getCompounds().size()];
		HashMap<Vertex, Integer> inDegHash = new HashMap<Vertex, Integer>(getCompounds().size(), 1f);
		HashMap<Vertex, Integer> outDegHash = new HashMap<Vertex, Integer>(getCompounds().size(), 1f);
		float[] inDegN = new float[getCompounds().size()];
		float[] outDegN = new float[getCompounds().size()];
		int sumInDeg = 0, sumOutDeg = 0;
		float sumInDegN = 0, sumOutDegN = 0;
		int ins = 0, outs = 0;
		
		// get the in- and out-degrees of all compounds and their neighbors and the means
		int i=0; 
		for (Vertex compound : getCompounds()) {
			
			// get the neighbour compounds
			HashSet<Vertex> predecessors = predecessorsOf(compound);
			HashSet<Vertex> successors = successorsOf(compound);
			// get the degrees
			inDeg[i] = predecessors.size();
			outDeg[i] = successors.size();
			inDegHash.put(compound, inDeg[i]);
			outDegHash.put(compound, outDeg[i]);
			sumInDeg += inDeg[i];
			sumOutDeg += outDeg[i];
			// get the average degrees of the neighborhood
			if (inDeg[i] > 0) {
				for (Vertex predecessor : predecessors) {
					// if the in-degree was already calculated use this one
					Integer inDegreeN = inDegHash.get(predecessor);
					inDegN[i] += (inDegreeN != null ? inDegreeN : predecessorsOf(predecessor).size());
				}
				inDegN[i] /= (float)inDeg[i];
				sumInDegN += inDegN[i];
				ins++;
			}
			if (outDeg[i] > 0) {
				for (Vertex successor : successors) {
					// if the out-degree was already calculated use this one
					Integer outDegreeN = outDegHash.get(successor);
					outDegN[i] += (outDegreeN != null ? outDegreeN : successorsOf(successor).size());
				}
				outDegN[i] /= (float)outDeg[i];
				sumOutDegN += outDegN[i];
				outs++;
			}
			
			if (debug) {
				System.out.println(compound.getName()+" has in-degree "+inDeg[i]+", out-degree "+outDeg[i]);
				System.out.println("Predecessors:");
				for (Vertex predecessor : predecessors) {
					System.out.println(predecessor.getName()+", in-degree: "+predecessorsOf(predecessor).size());
				}
				System.out.println("avg. in-degree of predecessors "+inDegN[i]);
				System.out.println("Successors:");
				for (Vertex successor : successors) {
					System.out.println(successor.getName()+", out-degree: "+successorsOf(successor).size());
				}
				System.out.println("avg. out-degree of successors "+outDegN[i]);
				System.out.println();
			}
			
			i++;
		}
		
		float meanInDeg = (float)sumInDeg/(float)ins;
		float meanOutDeg = (float)sumOutDeg/(float)outs;
		float meanInDegN = (float)sumInDegN/(float)ins;
		float meanOutDegN = (float)sumOutDegN/(float)outs;
		

		assortativities[0] = correlation(inDeg, meanInDeg, inDegN, meanInDegN);
		assortativities[1] = correlation(outDeg, meanOutDeg, outDegN, meanOutDegN);		
//		assortativities[1] = correlation(inDeg, meanInDeg, outDegN, meanOutDegN);
//		assortativities[2] = correlation(outDeg, meanOutDeg, inDegN, meanInDegN);
		
//		System.out.println(assortativities[0]+", "+assortativities[1]);
		
		return assortativities;
	}
	
	/**
	 * @deprecated
	 * @return double[] of size 2 containing the in-degree/in-degree correlation coefficient
	 * at index 0, and the out-degree/out-degree correlation coefficient at index 1.
	 */
	public double[] assortativities_old() {
		boolean debug = false;
		double[] assortativities = new double[4];
		int[] inDeg = new int[getCompounds().size()];
		int[] outDeg = new int[getCompounds().size()];
		float[] inDegN = new float[getCompounds().size()];
		float[] outDegN = new float[getCompounds().size()];
		int sumInDeg = 0, sumOutDeg = 0;
		float sumInDegN = 0, sumOutDegN = 0;
		int ins = 0, outs = 0;
		
		// get the in- and out-degrees of all compounds and their neighbors and the means
		int i=0; 
		for (Vertex compound : getCompounds()) {
			
			// get the neighbour compounds
			HashSet<Vertex> predecessors = predecessorsOf(compound);
			HashSet<Vertex> successors = successorsOf(compound);
			// get the degrees
			inDeg[i] = predecessors.size();
			outDeg[i] = successors.size();
			sumInDeg += inDeg[i];
			sumOutDeg += outDeg[i];
			// get the average degrees of the neighborhood
			if (inDeg[i] > 0) {
				for (Vertex predecessor : predecessors)
					inDegN[i] += predecessorsOf(predecessor).size();
				inDegN[i] /= (float)inDeg[i];
				sumInDegN += inDegN[i];
				ins++;
			}
			if (outDeg[i] > 0) {
				for (Vertex successor : successors)
					outDegN[i] += successorsOf(successor).size();
				outDegN[i] /= (float)outDeg[i];
				sumOutDegN += outDegN[i];
				outs++;
			}
			
			if (debug) {
				System.out.println(compound.getName()+" has in-degree "+inDeg[i]+", out-degree "+outDeg[i]);
				System.out.println("Predecessors:");
				for (Vertex predecessor : predecessors) {
					System.out.println(predecessor.getName()+", in-degree: "+predecessorsOf(predecessor).size());
				}
				System.out.println("avg. in-degree of predecessors "+inDegN[i]);
				System.out.println("Successors:");
				for (Vertex successor : successors) {
					System.out.println(successor.getName()+", out-degree: "+successorsOf(successor).size());
				}
				System.out.println("avg. out-degree of successors "+outDegN[i]);
				System.out.println();
			}
			
			i++;
		}
		
		float meanInDeg = (float)sumInDeg/(float)ins;
		float meanOutDeg = (float)sumOutDeg/(float)outs;
		float meanInDegN = (float)sumInDegN/(float)ins;
		float meanOutDegN = (float)sumOutDegN/(float)outs;
		
		assortativities[0] = correlation(inDeg, meanInDeg, inDegN, meanInDegN);
		assortativities[1] = correlation(outDeg, meanOutDeg, outDegN, meanOutDegN);		
//		assortativities[1] = correlation(inDeg, meanInDeg, outDegN, meanOutDegN);
//		assortativities[2] = correlation(outDeg, meanOutDeg, inDegN, meanInDegN);
		
//		System.out.println(assortativities[0]+", "+assortativities[1]);
		
		return assortativities;
	}
	
	/**
	 * Calculates the empirical pearson correlation of x and y with given
	 * means meanX and meanY. Zeros in x are skipped.
	 * 
	 * @param x
	 * @param meanX
	 * @param y
	 * @param meanY
	 * @return Correlation coefficient.
	 */
	public double correlation(int[] x, float meanX, float[] y, float meanY) {
		if (x.length != y.length)
			throw new IllegalArgumentException("Unequal array lengths: "+x.length+" and "+y.length+".");
		
		// calculate the empirical pearson correlation
		float numerator = 0;
		double denominator1 = 0, denominator2 = 0;
		
		for (int i=0; i<x.length; i++) {
			if (x[i] != 0) {
				numerator += ((x[i]-meanX)*(y[i]-meanY));
				denominator1 += Math.pow(x[i]-meanX, 2);
				denominator2 += Math.pow(y[i]-meanY, 2);
			}
		}
		
		return (double)(numerator)/(Math.sqrt(denominator1*denominator2));
	}
	
	/**
	 * Calculates the local essentiality of reaction1 for reaction2, i.e., the
	 * reciprocal of the smallest in-degree of a product of reaction1 which is
	 * substrate of reaction2, or 0, if no such compound exists.
	 * 
	 * If reversible==false, both directions of reversible reactions are considered
	 * independently, otherwise the essentiality of reaction1 is measured by
	 * considering both its substrates and products. For reaction2 only substrates
	 * are considered in any case.  
	 * 
	 * Note: imprecision possible due to numerical errors.
	 * 
	 * @param reaction1
	 * @param reaction2
	 * @param reversible
	 * @return local centrality between reaction1 and reaction2.
	 */
	public double localCentrality(Vertex reaction1, Vertex reaction2, boolean reversible) {
		int minInDegree = Integer.MAX_VALUE;
		
		// set the essentiality between both directions of a reversible reaction to 0 
		if (reaction1.reversedReaction() != null && reaction1.reversedReaction().equals(reaction2))
			return 0;
		
		// iterate over the substrates of reaction2
		for (Vertex compound : Graphs.predecessorListOf(this, reaction2)) {
			// get the smallest in-degree of a compound which is product of reaction1
			// if reversed==true and reaction1 is reversible, then both substrates and products of reaction1 are considered 
			if (getEdge(reaction1, compound) != null || (reversible && reaction1.reversedReaction() != null && getEdge(reaction1.reversedReaction(), compound) != null)) {
				if (inDegreeOf(compound) < minInDegree)
					minInDegree = inDegreeOf(compound);
			}
		}
		
		if (minInDegree == Integer.MAX_VALUE)
			return 0;
		else
			return (double)1/(double)minInDegree;
	}
	
	public double localCentrality(HashSet<Vertex> products, HashSet<Vertex> substrates) {
		int minInDegree = Integer.MAX_VALUE;
		
		// iterate over the given intermediaries
		for (Vertex compound : substrates) {
			// get the smallest in-degree of overlapping compounds
			if (products.contains(compound))
				if (inDegreeOf(compound) < minInDegree)
					minInDegree = inDegreeOf(compound);
		}
		
		if (minInDegree == Integer.MAX_VALUE)
			return 0;
		else
			return (double)1/(double)minInDegree;
	}
	
	/**
	 * Calculates the local reaction essentiality, i.e., the sum of essentialities of
	 * the reaction for all its successor reactions.
	 * 
	 * If reversible==false, only the given direction of the reaction is considered,
	 * otherwise both directions of a reversible reaction are considered together.
	 * 
	 * @param reaction
	 * @return local essentiality of the reaction.
	 */
	public double localEssentiality(Vertex reaction, boolean reversible) {
		double essentiality = 0;
		if (!reaction.getType() == Vertex.REACTION)
			throw new IllegalArgumentException("Method applicable only to vertices of type Vertex.REACTION.");
		
		if (outDegreeOf(reaction) == 0)
			return 0;
		
		// iterate over the successor reactions
		for (Vertex successor : ((reversible && reaction.reversedReaction() != null) ? neighborsOf(reaction) : successorsOf(reaction))) {
			
			// may return 0, if successor is the unaffected direction of a reversible reaction
			double localEssentiality = localCentrality(reaction, successor, reversible);
			
			// add the local essentiality
			essentiality += localEssentiality;
		}
		
		return essentiality;
	}
	
	/**
	 * From a given knockout reaction, returns the set of reactions that are
	 * affected by the knockout, and their knockout strength, up to the given threshold.
	 * The knockout strength is determined by the maximum product of the local essentialities
	 * along any path from the knockout to the affected reaction.
	 * 
	 * If the initial knockout reaction is reversible, both directions are considered to
	 * be knocked out. For the propagation, only the affected reaction directions are considered.
	 * 
	 * @param knockout
	 * @param threshold
	 * @see MetabolicGraph#localEssentiality(Vertex,boolean) MetabolicGraph.localEssentiality(Vertex,boolean)
	 * @return HashMap of vertices and their knockout path up to the specified threshold.
	 */
	public HashMap<Vertex, Double[]> knockoutSet(Vertex knockout, double threshold) {
		if (threshold <= 0 || threshold > 1)
			throw new IllegalArgumentException("Invalid knockout essentiality threshold: must be in ]0,1].");
		if (knockout.getType() != Vertex.REACTION)
			throw new IllegalArgumentException("Vertex knockout must be of type Vertex.REACTION.");
		
		HashMap<Vertex, Double[]> path = new HashMap<Vertex, Double[]>((int)(outDegreeOf(knockout)/threshold)+1);
		// add the reaction itself and its reversed direction, if it is reversible
		path.put(knockout, new Double[]{1d, localEssentiality(knockout, true)});
		if (knockout.reversedReaction() != null)
			path.put(knockout.reversedReaction(), new Double[]{1d, localEssentiality(knockout.reversedReaction(), true)});
		// run the depth first search
		path.putAll(knockoutPathDFS(path, knockout, true, threshold, 1d));
		
		return path;
	}
	
	/**
	 * Depth-first-search for the reactions that are affected by the knockout of the given reaction,
	 * and their knockout strength, propagated by multiplying the local essentiality values along
	 * the path up to the given threshold.
	 * 
	 * The knockout of the initial reaction is considered bidirectional for reversible reactions,
	 * while for the propagation only the affected reaction direction is considered.
	 * 
	 * @param path
	 * @param knockout
	 * @param threshold
	 * @param factor
	 * @return
	 */
	private HashMap<Vertex, Double[]> knockoutPathDFS(HashMap<Vertex, Double[]> path, Vertex knockout, boolean first, double threshold, double factor) {
		
		for (Vertex successor : (first ? neighborsOf(knockout) : successorsOf(knockout))) {
			
			double essentiality = localCentrality(knockout, successor, first);
			
			// stop recursion if the propagated essentiality falls below the threshold
			if (essentiality*factor >= threshold) {
				// stop recursion if the node was already visited with equal or greater propagated essentiality
				if (path.containsKey(successor) && path.get(successor)[0] >= essentiality*factor)
					continue;
				// add the successor, or increase its essentiality value, if it already exists
				path.put(successor, new Double[]{essentiality*factor, localEssentiality(successor, false)});
				// add the next successors recursively with propagated essentiality
				path.putAll(knockoutPathDFS(path, successor, false, threshold, essentiality*factor));
			}
		}
		
		return path;
	}
	
	/**
	 * <p>
	 * Calculates the global propagation of the local reaction centralities. These
	 * are given by the eigenvector corresponding to the largest eigenvalue of the
	 * reaction incidence matrix, normalized by the page rank transformation with
	 * damping factor d. The reaction incidence matrix is an m x m matrix containing
	 * the local essentiality scores between pairs of reactions. 
	 * 
	 * <p>
	 * If originalGraph==null, then the reaction centralities are calculated from
	 * this graph. Otherwise, the centralities are calculated repeatedly by preserving
	 * every reaction, one at a time. This allows calculating the centrality of a reaction
	 * randomized network while preserving the reaction itself, without additional
	 * randomization runs. originalGraph must be the original graph from which this
	 * network was randomized.   
	 * 
	 * <p>
	 * If reversible==true, then the local dependence between a source reaction and a target
	 * reaction is the same for both directions of a reversible source reaction (the
	 * knockout of the source affects both its directions equally). Otherwise, the local
	 * dependence considers both directions of a reversible source reaction independently.
	 * Note that both directions of a reversible target reaction are always affected
	 * independently (a knockout affects both directions independently).
	 * 
	 * @see MetabolicGraph#localCentrality(Vertex,Vertex,boolean)
	 * @see MetabolicGraph#localCentrality(HashSet,HashSet)
	 * @see MetabolicGraph#eigenvectorFloat(float[],int,double,boolean)
	 * @see MetabolicGraph#eigenvectorDouble(double[],int,double,boolean)
	 * @param originalGraph The originalGraph (not randomized) required for preserving 
	 * each reaction one at a time.
	 * @param d Damping factor for the PageRank transformation.
	 * @param doublePrecision If true, calculates the eigenvector in double precision,
	 * otherwise float precision.
	 * @param reversible If true, both directions of a reversible source reaction are considered
	 * as one, otherwise both directions are considered independently.
	 * @return TreeMap containing the reaction vertices as key and their centrality score
	 * as Number.
	 */
	public TreeMap<Vertex, Number> reactionCentralities(MetabolicGraph originalGraph, double d, boolean doublePrecision, boolean reversible) {
		Collection<Vertex> reactionsSet = new HashSet<Vertex>(getReactions());
		TreeMap<Vertex, Number> centralities = new TreeMap<Vertex, Number>(new VertexComparator());
		
		// add the reversed reactions
		for (Vertex reaction : getReactions())
			if (reaction.reversedReaction() != null)
				reactionsSet.add(reaction.reversedReaction());
		
		// sort the reactions by name (and implicitly by reversedness)
		ArrayList<Vertex> reactionsList = new ArrayList<Vertex>(reactionsSet);
		Collections.sort(reactionsList, new VertexComparator());
		
		// construct the reaction essentiality incidence matrix as Fortran style arrays (column order)
		int m = reactionsList.size();
		
		// if originalGraph != null, preserve each reaction once
		// otherwise this is the original graph, and the for-loop is iterated only once
		int run = 1, decimal = 1, twentieth = 1;
		for (Vertex preserved : reactionsList) {
			
			// skip reversed reactions: they are preserved with the forward reaction, as they have the same name
			if (preserved.isReversed())
				continue;
			
			float[] A = new float[m*m];
			double[] A_double = new double[m*m];
			
			// construct the reaction essentiality matrix
			for (int i=0; i<m; i++) {
				for (int j=0; j<m; j++) {
					
					Vertex source = reactionsList.get(i);
					Vertex target = reactionsList.get(j);
					// set the essentiality between both directions of a reversible reaction to 0
					if (source.reversedReaction() != null && source.reversedReaction().equals(target)) {
						if (doublePrecision)
							A_double[m*j+i] = 0;
						else
							A[m*j+i] = 0;
						
					} else {
						// collect the products of the source and the substrates of the target reaction
						HashSet<Vertex> substrates = new HashSet<Vertex>();
						HashSet<Vertex> products = new HashSet<Vertex>();
						// if the source reaction is the one to be preserved, collect the products of the corresponding reaction in the original graph (and substrates if the source reaction is reversible)
						if (originalGraph != null && preserved.getName().equals(source.getName())) {
							List<Vertex> originalProducts = Graphs.successorListOf(originalGraph, source.isReversed() ? originalGraph.getReaction(source.getName()).reversedReaction() : originalGraph.getReaction(source.getName()));
							// if the source reaction is reversible and reversible==true, also add its substrates
							if (reversible && source.reversedReaction() != null)
								originalProducts.addAll(Graphs.predecessorListOf(originalGraph, source.isReversed() ? originalGraph.getReaction(source.getName()).reversedReaction() : originalGraph.getReaction(source.getName())));
							for (Vertex product : originalProducts)
								products.add(getCompound(product.getName(), product.getCompartment()));
						} else {
							// if this is the original graph or the reaction is not to be preserved, take the products of the source reaction in this graph
							products = new HashSet<Vertex>(Graphs.successorListOf(this, source));
							// if the source reaction is reversible and reversible==true, also add its substrates
							if (reversible && source.reversedReaction() != null)
								products.addAll(Graphs.predecessorListOf(this, source));
						}
						// if the target reaction is the one to be preserved, collect the substrates of the corresponding reaction in the original graph
						if (originalGraph != null && preserved.getName().equals(target.getName())) {
							List<Vertex> originalSubstrates = Graphs.predecessorListOf(originalGraph, target.isReversed() ? originalGraph.getReaction(target.getName()).reversedReaction() : originalGraph.getReaction(target.getName()));
							for (Vertex substrate : originalSubstrates)
								substrates.add(getCompound(substrate.getName(), substrate.getCompartment()));
						} else {
							// take the substrates of the target reaction in this (original) graph
							substrates = new HashSet<Vertex>(Graphs.predecessorListOf(this, target));
						}
						// set i,j to the local essentiality between products of the source reaction and the substrates of the target reaction
						double essentiality = localCentrality(products, substrates);
						if (doublePrecision)
							A_double[m*j+i] = essentiality;
						else
							A[m*j+i] = (float)essentiality;
					}
				}
			}
			
			// run the eigenvector calculation
			if (doublePrecision) {
				// if there is no preserved reaction take the full eigenvector and exit
				if (originalGraph == null) {
					double[] eigenvector = eigenvectorDouble(A_double, m, d, true);
					for (int i=0; i<m; i++)
						centralities.put(reactionsList.get(i), (eigenvector == null ? null : eigenvector[i]));
					break;
				} else {
					// add the centrality of the preserved reaction, if available
					double[] eigenvector = eigenvectorDouble(A_double, m, d, false);
					centralities.put(preserved, (eigenvector == null ? null : eigenvector[reactionsList.indexOf(preserved)]));
					// add the centrality of the reversed direction, which is different even if reversible==true
					Vertex reversed = preserved.reversedReaction();
					if (reversed != null)
						centralities.put(reversed, (eigenvector == null ? null : eigenvector[reactionsList.indexOf(reversed)]));
				}
			} else {
				// if there is no preserved reaction take the full eigenvector and exit
				if (originalGraph == null) {
					float[] eigenvector = eigenvectorFloat(A, m, d, true);
					for (int i=0; i<m; i++)
						centralities.put(reactionsList.get(i), (eigenvector == null ? null : eigenvector[i]));
					break;
				} else {
					// add the centrality of the preserved reaction, if available
					float[] eigenvector = eigenvectorFloat(A, m, d, false);
					centralities.put(preserved, (eigenvector == null ? null : eigenvector[reactionsList.indexOf(preserved)]));
					// add the centrality of the reversed direction, which is different even if reversible==true
					Vertex reversed = preserved.reversedReaction();
					if (reversed != null)
						centralities.put(reversed, (eigenvector == null ? null : eigenvector[reactionsList.indexOf(reversed)]));
				}
			}
			
			// progress output: 5% and '.' at 1%
			if (reactionsList.size() >= 20 && (run*20/twentieth) >= reactionsList.size()) {
				System.out.print((5*twentieth) + "%");
				decimal++;
				twentieth++;
			} else if (reactionsList.size() >= 100 && (run*100/decimal) >= reactionsList.size()) {
				System.out.print(".");
				decimal++;
			}
			run++;
		}
		
		return centralities;
	}
	
	/**
	 * <p>
	 * Calculates the eigenvector corresponding to the largest eigenvalue of A using the
	 * Fortran routines snaupd and sgemv. If the fast calculation using the Arnoldi
	 * method fails, then the eigenvector corresponding to the largest eigenvalue is
	 * determined from the full eigenvalue spectrum using the LAPACK routine sgeev
	 * ({@link MetabolicGraph#eigenvalueDecomposition(float[],int)}.
	 * 
	 * <p>
	 * Before eigenvalue calculation, the matrix A is normalized according to page rank
	 * with damping factor d:<br>
	 * A_i,j = e(r_i,r_j)*(A_i,j/colsum_j)*d+(1-d)/m)<br>
	 * where e(r_i,r_j) = max(1/inDegreeOf(c)) is the local essentiality for all c which are
	 * a product of r_i and a substrate of r_j, or 0, if no such c exists;<br>
	 * colsum_j is the sum of all entries of column j;<br>
	 * m is the number of columns/rows.
	 * 
	 * <p>
	 * The <a href="http://code.google.com/p/netlib-java/" target="_blank">netlib-java</a>
	 * Fortran interfaces to ARPACK were used for eigenvalue calculation, as they clearly
	 * outperformed five other java based libraries: Shared, JAMA, Colt, JBLAS, MTJ,
	 * as well as Fortran routines for calculating all eigenvalues, JLAPACK.
	 * 
	 * <p>
	 * However, the ARPACK routines for directly calculating the largest eigenvalue
	 * are unstable for some parameters. If an error occurs, the eigenvector corresponding
	 * to the largest eigenvalue is determined from the full eigenvalue spectrum
	 * using the LAPACK routines sgeev or dgeev ({@link MetabolicGraph#eigenvalueDecomposition(float[],int)}
	 * or {@link MetabolicGraph#eigenvalueDecomposition(float[],int)}).
	 * 
	 * <p>
	 * Most critical parameters for the ARPACK routines are INFO, TOL, RESID and NCV.
	 * Certain values of TOL seem to cause numerical errors or a number overflow when using
	 * double precision and certain initial residual vectors RESID, either with INFO==0 or
	 * INFO==1. NCV causes error message if inadequate values are set.
	 * 
	 * <p>
	 * The following parameters seem to be more or less stable for both float and double precision:
	 * 	d=0.85 or d=0.9
	 * 	TOL = Float.MIN_VALUE, resp. Double.MIN_VALUE
	 * 	INFO = 0
	 * 	RESID = new float[N], resp. new double[N]; (no initial residuals)
	 * 	NCV = Math.min(Math.max(2*NEV+1, 20), N);
	 * 
	 * <p>
	 * The important parameter is d. The dgems/sgemv methods are highly unstable for other values of
	 * d, e.g. d=0.99, d=0.95, and d=0.995.
	 * 
	 * <p>
	 * The following references were most informative for using ARPACK:
	 * - R. B. Lehoucq, D. C. Sorensen, C. Yang: ARPACK Users' Guide: Solution of Large Scale Eigenvalue Problems with Implicitly Restarted Arnoldi Methods.
	 * - Matlab implementation of eigs: eigs.m
	 * - SciPy Development Wiki, for snaupd.f and sneupd.f
	 * - BLAS (Basic Linear Algebra Subprograms) documentation, particularly for sgemv.f.
	 * 
	 * 
	 * @param A Matrix for calculating the eigenvector in Fortran matrix style.
	 * @param m Number of rows/columns in A.
	 * @param d Damping factor.
	 * @param forceDecomposition If true and an error occurs, calculates the full eigenvalue spectrum.
	 * @see MetabolicGraph#reactionCentralities(MetabolicGraph,double,boolean,boolean)
	 * @see MetabolicGraph#eigenvectorDouble(double[],int,double,boolean)
	 * @return The eigenvector corresponding to the largest eigenvalue.
	 */
	public float[] eigenvectorFloat(float[] A, int m, double d, boolean forceDecomposition) {
		boolean debug = false, errors = true;
		final int maxTries = 5; 
		long time = 0;
		final double epsilon = 0.00001;
		float[] eigenvector;
		
//		if (debug) {
			// print the original matrix
//			try {
//				BufferedWriter writer = new BufferedWriter(new FileWriter(file+".original", false));
//				for (int i=0; i<m; i++) {
//					for (int j=0; j<m; j++) {
//						writer.write(String.valueOf(A[m*j+i]));
//						writer.write(j < m-1 ? "\t" : "\n");
//					}
//				}
//				writer.close();
//				
//			} catch (IOException e) {
//				e.printStackTrace();
//			}
//		}
		
		// normalize the columns to sum up to 1, then apply the damping factor
		for (int j=0; j<m; j++) {
			double sum = 0;
			for (int i=0; i<m; i++)
				sum += (A[m*j+i]);
			for (int i=0; i<m; i++) {
				if (sum != 0) {
					A[m*j+i] = (float)((A[m*j+i]/sum)*d+(1-d)/m);
				} else {
					A[m*j+i] = (float)((d/m)+(1-d)/m);
				}
			}
		}
		
		if (debug) {
			System.out.println("Eigenvalue decomposition (ARPACK, float precision)...");
			time = System.currentTimeMillis();
		}
		
		int invalid = 0;
		// repeat if there was an error 
		do {
			// ARPACK variables used for both single and double precision routines
			org.netlib.util.intW IDO = new org.netlib.util.intW(0); // initial operation mode: 0
			String BMAT = "I"; // type: standard eigenvalue problem: Ax=yBx with B=I, i.e., Ax=yx
			int N = m; // number of matrix rows/columns
			String WHICH = "LM"; // desired eigenvalues: Largest Magnitude
			int NEV = 1; // number of desired eigenvalues
			// snaupd.f, dnaupd.f: "At present there is no a-priori analysis to guide the selection NCV relative to NEV.
			// The only formal requrement is that NCV > NEV + 2. However, it is recommended that NCV >= 2*NEV+1."
			// eigs.m: "number of Lanczos vectors: p = min(max(2*k,20),n);" (k==NEV)
			// "Number of basis vectors opts.p must be a positive integer <= n.'
			// For nonsymmetric and complex problems, must have number of basis vectors opts.p > k+1."
			int NCV = Math.min(Math.max(2*NEV+1, 20), N);
			int maxNCV = NCV*NCV;
			int[] IPNTR = new int[14]; // OUTPUT only
			int LDV = N; // values causing error by LDH in SGEMV: 0, 1, 256 // If Ritz vectors are desired, then  LDZ >= max( 1, N )
			// test another value for MXITER: maxitr = 300
			int MAXITER = (int)Math.max(300., Math.ceil((double)(2*N)/(double)Math.max(NCV, 1))); // Matlab eigs.m: maxit = max(300,ceil(2*n/max(p,1)));
			int[] IPARAM = {/*ISHIFT*/1, /*<unused>*/0, MAXITER, /*NB*/0, /*NCONV*/0, /*<unused>*/0, /*MODE*/1, 0, 0, 0, 0};
			boolean[] SELECT = new boolean[NCV];
			int LDZ = LDV;
			// eigs.m: "Always use resid as the start vector, whether it is OPTS.v0 or randomly generated within eigs."
			org.netlib.util.intW INFO = new org.netlib.util.intW(1); // 1: use RESID as initial residue vector, 0: random initial residue vector
			// the result eigenvector
			eigenvector = null;

			// JARPACK: compute the eigenvalue of largest magnitude
			// variables for snaupd
			org.netlib.util.floatW TOL = new org.netlib.util.floatW(Float.MIN_VALUE);
			float[] RESID = new float[N], V = new float[N*NCV], WORKL = new float[3*maxNCV*maxNCV+6*maxNCV], WORKD = new float[3*N];
			int LWORKL = WORKL.length; //3*NCV^2+6*NCV; eigs.m: lworkl = intconvert(3*p*(p+2)); // LWORKL must be at least 3*NCV**2 + 6*NCV
			// initialize the residual vector with random values
			Random r = new Random();
			for (int i=0; i<RESID.length; i++)
				RESID[i] = r.nextFloat();
			
			// main reverse communication loop: snaupd is called and w=A*v is passed to WORKD, until convergence
			do {
				// the following args are set to zero anyway in snaupd (see JARPACK.java): 8, 11, 14, 16, 18, 20 (starting index 1)
				org.netlib.arpack.Snaupd.snaupd(IDO, BMAT, N, WHICH, NEV, TOL, RESID, 0, NCV, V, 0, LDV, IPARAM, 0, IPNTR, 0, WORKD, 0, WORKL, 0, LWORKL, INFO);
				// compute w=A*v, where v = WORKD[IPNTR[0]] and w =WORKD[IPNTR[1]]
				float[] X = new float[m], Y = new float[m];
				for (int i=0; i<X.length; i++)
					X[i] = WORKD[IPNTR[0]-1+i];
				org.netlib.blas.Sgemv.sgemv("N", m, m, 1f, A, 0, m, X, 0, 1, 0f, Y, 0, 1);
				for (int i=0; i<m; i++)
					WORKD[IPNTR[1]-1+i] = Y[i];
				
			} while (IDO.val == -1 || IDO.val == 1);
			
			// check for errors in snaupd and sgemv
			if (IDO.val != 99) {
				invalid++;
				if (errors)
					System.out.print("IDO from ARPACK function SNAUPD had an illegal exit status ["+invalid+"]: "+IDO.val+". ");
			} else if (INFO.val != 0) {
				invalid++;
				String message = "INFO from ARPACK function SNAUPD had non-zero exit status ["+invalid+"]: "+INFO.val+". ";
//				if (INFO.val == -8)
//					message += "Consider decreasing NCV (currently "+NCV+"). ";
				if (errors)
					System.out.print(message);
			} else {
				// extract the eigenvalue and eigenvector with sneupd
				float SIGMAR = 0, SIGMAI = 0;
				float[] WORKEV = new float[3*NCV], DR = new float[NEV+1], DI = new float[NEV+1];
				float[] Z = new float[N*(NEV+1)];
				org.netlib.util.intW NEV2 = new org.netlib.util.intW(NEV);
				org.netlib.arpack.Sneupd.sneupd(true, "A", SELECT, 0, DR, 0, DI, 0, Z, 0, LDZ, SIGMAR, SIGMAI, WORKEV, 0, BMAT, N, WHICH, NEV2, TOL.val, RESID, 0, NCV, V, 0, LDV, IPARAM, 0, IPNTR, 0, WORKD, 0, WORKL, 0, LWORKL, INFO);
			
				if (debug) {
					System.out.println(((System.currentTimeMillis()-time)/(float)1000)+" seconds.");
					System.out.println("Largest eigenvalue is "+DR[0]+" + "+DI[0]+"i.");
				}
				
				// check for errors in sneupd
				if (INFO.val != 0) {
					// non-zero exit status
					invalid++;
					if (errors)
						System.out.print("INFO from ARPACK function SNEUPD had non-zero exit status ["+invalid+"]: "+INFO.val+". ");
				} else if (Math.abs(DR[1]) > epsilon) {
					// complex eigenvalue
					invalid++;
					if (errors)
						System.out.print("Eigenvalue is not real ["+invalid+"]: "+DR[0]+" + "+DR[1]+"i. ");
				} else if (Math.abs((DR[0] - 1)) > epsilon) {
					// eigenvalue unequals one
					invalid++;
					if (errors)
						System.out.print("Eigenvalue is not one ["+invalid+"]: "+DR[0]+". ");
				} else {
					// check for complex eigenvector scalar
					boolean complexScalar = false;
					for (int i=0; i<m; i++) {
						if (Math.abs(Z[m+i]) > epsilon) {
							invalid++;
							if (errors) 
								System.out.print("Complex eigenvector scalar "+Z[i]+"+"+Z[m+i]+" for index "+i+" ["+invalid+"]. ");
							complexScalar = true;
							break;
						}
					}
					// no error
					if (!complexScalar)
						invalid = 0;
					
					eigenvector = Z;
				}
			}
			
		// repeat up to maxTries times in case there was an error
		} while (invalid != 0 && invalid < maxTries);
			
		if (invalid != 0) {
			// reverse communication had an error
			if (forceDecomposition) {
				// run the full eigenvalue spectrum using sgeev
				if (debug)
					System.out.print("Running full eigenvalue decomposition. ");
				System.out.print("!");
				eigenvector = eigenvalueDecomposition(A, m);
			} else {
				eigenvector = null;				
			}
		}
		
		if (debug)
			System.out.println(((System.currentTimeMillis()-time)/(float)1000)+" seconds. ");
		
		return eigenvector;
	}
	
	/**
	 * <p>
	 * Calculates the eigenvector corresponding to the largest eigenvalue of A using the
	 * Fortran routines dnaupd and dgemv. If the fast calculation using the Arnoldi
	 * method fails, then the eigenvector corresponding to the largest eigenvalue is
	 * determined from the full eigenvalue spectrum using the LAPACK routine dgeev
	 * ({@link MetabolicGraph#eigenvalueDecomposition(double[],int)}.
	 * 
	 * <p>
	 * Before eigenvalue calculation, the matrix A is normalized according to page rank
	 * with damping factor d:<br>
	 * A_i,j = e(r_i,r_j)*(A_i,j/colsum_j)*d+(1-d)/m)<br>
	 * where e(r_i,r_j) = max(1/inDegreeOf(c)) is the local essentiality for all c which are
	 * a product of r_i and a substrate of r_j, or 0, if no such c exists;<br>
	 * colsum_j is the sum of all entries of column j;<br>
	 * m is the number of columns/rows.
	 * 
	 * <p>
	 * See {@link MetabolicGraph#eigenvalueDecomposition(float[],int)} for additional
	 * information.
	 * 
	 * @param A Matrix for calculating the eigenvector in Fortran matrix style.
	 * @param m Number of rows/columns in A.
	 * @param d Damping factor.
	 * @param forceDecomposition If true and an error occurs, calculates the full eigenvalue spectrum.
	 * @see MetabolicGraph#reactionCentralities(MetabolicGraph,double,boolean,boolean)
	 * @see MetabolicGraph#eigenvectorFloat(float[],int,double,boolean)
	 * @return The eigenvector corresponding to the largest eigenvalue.
	 */
	public double[] eigenvectorDouble(double[] A, int m, double d, boolean forceDecomposition) {
		boolean debug = false, errors = true;
		final int maxTries = 5;
		long time = 0;
		final double epsilon = 0.00001;
		double[] eigenvector;
		
//		if (debug) {
//			// print the original matrix
//			try {
//				BufferedWriter writer = new BufferedWriter(new FileWriter(file+".original", false));
//				for (int i=0; i<m; i++) {
//					for (int j=0; j<m; j++) {
//						writer.write(String.valueOf(A[m*j+i]));
//						writer.write(j < m-1 ? "\t" : "\n");
//					}
//				}
//				writer.close();
//				
//			} catch (IOException e) {
//				e.printStackTrace();
//			}
//		}
		
		// normalize the columns to sum up to 1, then apply the damping factor
		for (int j=0; j<m; j++) {
			double sum = 0;
			for (int i=0; i<m; i++)
				sum += (A[m*j+i]);
			for (int i=0; i<m; i++) {
				if (sum != 0) {
					A[m*j+i] = (A[m*j+i]/sum)*d+(1-d)/m;
				} else {
					A[m*j+i] = (d/m)+(1-d)/m;
				}
			}
		}
		
		if (debug) {
			System.out.println("Eigenvalue decomposition (ARPACK, double precision)...");
			time = System.currentTimeMillis();
		}
		
		int invalid = 0;
		// repeat if there was an error 
		do {
			// ARPACK variables used for both single and double precision routines
			org.netlib.util.intW IDO = new org.netlib.util.intW(0); // initial operation mode: 0
			String BMAT = "I"; // type: standard eigenvalue problem: Ax=yBx with B=I, i.e., Ax=yx
			int N = m; // number of matrix rows/columns
			String WHICH = "LM"; // desired eigenvalues: Largest Magnitude
			int NEV = 1; // number of desired eigenvalues
			// snaupd.f, dnaupd.f: "At present there is no a-priori analysis to guide the selection NCV relative to NEV.
			// The only formal requrement is that NCV > NEV + 2. However, it is recommended that NCV >= 2*NEV+1."
			// eigs.m: "number of Lanczos vectors: p = min(max(2*k,20),n);" (k==NEV)
			// "Number of basis vectors opts.p must be a positive integer <= n.'
			// For nonsymmetric and complex problems, must have number of basis vectors opts.p > k+1."
			int NCV = Math.min(Math.max(2*NEV+1, 20), N);
			int maxNCV = NCV*NCV;
			int[] IPNTR = new int[14]; // OUTPUT only
			int LDV = N; // values causing error by LDH in SGEMV: 0, 1, 256 // If Ritz vectors are desired, then  LDZ >= max( 1, N )
			// test another value for MXITER: maxitr = 300
			int MAXITER = (int)Math.max(300., Math.ceil((double)(2*N)/(double)Math.max(NCV, 1))); // Matlab eigs.m: maxit = max(300,ceil(2*n/max(p,1)));
			int[] IPARAM = {/*ISHIFT*/1, /*<unused>*/0, MAXITER, /*NB*/0, /*NCONV*/0, /*<unused>*/0, /*MODE*/1, 0, 0, 0, 0};
			boolean[] SELECT = new boolean[NCV];
			int LDZ = LDV;
			// eigs.m: "Always use resid as the start vector, whether it is OPTS.v0 or randomly generated within eigs."
			org.netlib.util.intW INFO = new org.netlib.util.intW(1); // 1: use RESID as initial residue vector, 0: random initial residue vector
			// the result eigenvector
			eigenvector = null;
		
			// JARPACK: compute the eigenvalue of largest magnitude
			// variables for dnaupd
			org.netlib.util.doubleW TOL = new org.netlib.util.doubleW(Double.MIN_VALUE); // working with dgemv: 0.000001, 0.0000001, not working down to: 0.00000000000000001
			double[] RESID = new double[N], V = new double[N*NCV], WORKL = new double[3*maxNCV*maxNCV+6*maxNCV], WORKD = new double[3*N];
			int LWORKL = WORKL.length; //3*NCV^2+6*NCV; eigs.m: lworkl = intconvert(3*p*(p+2)); // LWORKL must be at least 3*NCV**2 + 6*NCV
			// initialize the residual vector with random values
			Random r = new Random();
			for (int i=0; i<RESID.length; i++)
				RESID[i] = r.nextDouble();
			
			// main reverse communication loop: dnaupd is called and w=A*v is passed to WORKD, until convergence
			do {
				// the following args are set to zero anyway in dnaupd (see JARPACK.java): 8, 11, 14, 16, 18, 20 (starting index 1)
				org.netlib.arpack.Dnaupd.dnaupd(IDO, BMAT, N, WHICH, NEV, TOL, RESID, 0, NCV, V, 0, LDV, IPARAM, 0, IPNTR, 0, WORKD, 0, WORKL, 0, LWORKL, INFO);
				// compute w=A*v, where v = WORKD[IPNTR[0]] and w =WORKD[IPNTR[1]]
				double[] X = new double[m], Y = new double[m];
				for (int i=0; i<X.length; i++)
					X[i] = WORKD[IPNTR[0]-1+i];
				org.netlib.blas.Dgemv.dgemv("N", m, m, 1., A, 0, m, X, 0, 1, 0., Y, 0, 1);
				for (int i=0; i<m; i++)
					WORKD[IPNTR[1]-1+i] = Y[i];
				
			} while (IDO.val == -1 || IDO.val == 1);
			
			// check for errors in dnaupd and dgemv
			if (IDO.val != 99) {
				invalid++;
				if (errors)
					System.out.print("IDO from ARPACK function DNAUPD had an illegal exit status ["+invalid+"]: "+IDO.val+". ");
			} else if (INFO.val != 0) {
				invalid++;
				String message = "INFO from ARPACK function DNAUPD had non-zero exit status ["+invalid+"]: "+INFO.val+". ";
//				if (INFO.val == -8)
//					message += "Consider decreasing NCV (currently "+NCV+"). ";
				if (errors)
					System.out.print(message);
			} else {
				// extract the eigenvalue and eigenvector with dneupd
				double SIGMAR = 0, SIGMAI = 0;
				double[] WORKEV = new double[3*NCV], DR = new double[NEV+1], DI = new double[NEV+1];
				double[] Z = new double[N*(NEV+1)];
				org.netlib.util.intW NEV2 = new org.netlib.util.intW(NEV);
				org.netlib.arpack.Dneupd.dneupd(true, "A", SELECT, 0, DR, 0, DI, 0, Z, 0, LDZ, SIGMAR, SIGMAI, WORKEV, 0, BMAT, N, WHICH, NEV2, TOL.val, RESID, 0, NCV, V, 0, LDV, IPARAM, 0, IPNTR, 0, WORKD, 0, WORKL, 0, LWORKL, INFO);
				
				if (debug) {
					System.out.println(((System.currentTimeMillis()-time)/(float)1000)+" seconds.");
					System.out.println("Largest eigenvalue is "+DR[0]+" + "+DI[0]+"i.");
				}
				
				// check for errors in dneupd
				if (INFO.val != 0) {
					// non-zero exit status
					invalid++;
					if (errors)
						System.out.print("INFO from ARPACK function DNEUPD had non-zero exit status ["+invalid+"]: "+INFO.val+". ");
				} else if (Math.abs(DR[1]) > epsilon) {
					// complex eigenvalue
					invalid++;
					if (errors)
						System.out.print("Eigenvalue is not real ["+invalid+"]: "+DR[0]+" + "+DR[1]+"i. ");
				} else if (Math.abs((DR[0] - 1)) > epsilon) {
					// eigenvalue unequals one
					invalid++;
					if (errors)
						System.out.print("Eigenvalue is not one ["+invalid+"]: "+DR[0]+". ");
				} else {
					// check for complex eigenvector scalar
					boolean complexScalar = false;
					for (int i=0; i<m; i++) {
						if (Math.abs(Z[m+i]) > epsilon) {
							invalid++;
							if (errors)
								System.out.print("Complex eigenvector scalar "+Z[i]+"+"+Z[m+i]+" for index "+i+" ["+invalid+"]. ");
							complexScalar = true;
							break;
						}
					}
					// no error
					if (!complexScalar)
						invalid = 0;
					
					eigenvector = Z;
				}
			}
			
		// repeat up to maxTries times in case there was an error
		} while (invalid != 0 && invalid < maxTries);
		
		if (invalid != 0) {
			// reverse communication had an error
			if (forceDecomposition) {
				// run the full eigenvalue spectrum using dgeev
				if (debug)
					System.out.print("Running full eigenvalue decomposition. ");
				System.out.print("!");
				eigenvector = eigenvalueDecomposition(A, m);
			} else {
				eigenvector = null; 
			}
		}
		
		if (debug)
			System.out.println(((System.currentTimeMillis()-time)/(float)1000)+" seconds. ");
		
		return eigenvector;
	}

	/**
	 * Calculates the full eigenvalue spectrum with double precision using the Fortran method dgeev.
	 * 
	 * @param matrix The matrix in Fortran-style array format (column order).
	 * @param m Number of reactions.
	 * @return The eigenvector corresponding to the largest eigenvalue of the given matrix.
	 * @see MetabolicGraph#reactionCentralities(MetabolicGraph,double,boolean,boolean)
	 */
	public double[] eigenvalueDecomposition(double[] matrix, int m) {
		boolean debug = false;
		final double epsilon = 0.00001;
		long time = System.currentTimeMillis();
		double[] eigenvector = new double[m];
		org.netlib.util.intW INFO = new org.netlib.util.intW(0);
		int LDVL = 1, LDVR = m;
		double[] WR = new double[m], WI = new double[m];
		double[] VL = new double[LDVL*m];
		double[] VR = new double[LDVR*m];
		double[] WORK = new double[16*m]; // >=4*m. For good performance, LWORK must generally be larger.
		
		org.netlib.lapack.Dgeev.dgeev("N", "V", m, matrix, 0, m, WR, 0, WI, 0, VL, 0, LDVL, VR, 0, LDVR, WORK, 0, WORK.length, INFO);
		
		if (INFO.val != 0)
			throw new RuntimeException("INFO from LAPACK class dgeev had non-zero exit status: "+INFO.val);
		
		// get the largest eigenvalue
		int largestIndex = -1;
		double largest = Double.NEGATIVE_INFINITY;
		for (int i=0; i<WR.length; i++) {
			if (WR[i] > largest) {
				largest = WR[i];
				largestIndex = i;
			}
		}
		
		if (Math.abs((WR[largestIndex] - 1)) > epsilon)
			System.out.println("Eigenvalue is not one: "+WR[largestIndex]);
		if (Math.abs(WI[largestIndex]) > epsilon)
			throw new RuntimeException("Eigenvalue is not real: "+WR[largestIndex]+" + "+WI[largestIndex]+"i");
		
		if (debug)
			System.out.println(WR[largestIndex]+" + "+WI[largestIndex]+"i "+"[index="+largestIndex+"].");
		
		for (int i=0; i<m; i++)
			eigenvector[i] = VR[largestIndex*m+i];
		
		if (debug)
			System.out.println("Full eigenvalue decomposition (double): "+((System.currentTimeMillis()-time)/(float)1000)+" seconds.");
		
		return eigenvector;
	}
	
	/**
	 * Calculates the full eigenvalue spectrum with float precision using the Fortran method sgeev.
	 * 
	 * @param matrix The matrix in Fortran-style array format (column order).
	 * @param m Number of reactions.
	 * @return The eigenvector corresponding to the largest eigenvalue of the given matrix.
	 * @see MetabolicGraph#reactionCentralities(MetabolicGraph,double,boolean,boolean)
	 */
	public float[] eigenvalueDecomposition(float[] matrix, int m) {
		boolean debug = false;
		long time = System.currentTimeMillis();
		float[] eigenvector = new float[m];
		org.netlib.util.intW INFO = new org.netlib.util.intW(0);
		int LDVL = 1, LDVR = m;
		float[] WR = new float[m], WI = new float[m];
		float[] VL = new float[LDVL*m];
		float[] VR = new float[LDVR*m];
		float[] WORK = new float[16*m]; // >=4*m. For good performance, LWORK must generally be larger.
		
		org.netlib.lapack.Sgeev.sgeev("N", "V", m, matrix, 0, m, WR, 0, WI, 0, VL, 0, LDVL, VR, 0, LDVR, WORK, 0, WORK.length, INFO);
		
		if (INFO.val != 0)
			throw new RuntimeException("INFO from LAPACK class sgeev had non-zero exit status: "+INFO.val);
	
		// get the largest eigenvalue
		int largestIndex = -1;
		float largest = Float.NEGATIVE_INFINITY;
		for (int i=0; i<WR.length; i++) {
			if (WR[i] > largest) {
				largest = WR[i];
				largestIndex = i;
			}
		}
		
		if (debug)
			System.out.println(WR[largestIndex]+" + "+WI[largestIndex]+"i "+"[index="+largestIndex+"].");
		
		for (int i=0; i<m; i++)
			eigenvector[i] = VR[largestIndex*m+i];
		
		if (debug)
			System.out.println("Full eigenvalue decomposition (float): "+((System.currentTimeMillis()-time)/(float)1000)+" seconds.");
		
		return eigenvector;
	}
	
//	public HashMap<String, Double> essentialities_simple(String file) {
//		boolean debug = true;
//		Collection<Vertex> reactionsSet = new HashSet<Vertex>(getReactions());
//		
//		System.out.print("Sorting...");
//		
//		// add the reversed reactions
//		for (Vertex reaction : getReactions())
//			if (reaction.reversedReaction() != null)
//				reactionsSet.add(reaction.reversedReaction());
//		
//		// sort the reactions by name and reversedness
//    	ArrayList<Vertex> reactionsList = new ArrayList<Vertex>(reactionsSet);
//    	Collections.sort(reactionsList, new Comparator<Vertex>() {
//    		public int compare(Vertex r1, Vertex r2) {
//    			if (r1.getName().equals(r2.getName()))
//    				return (r2.isReversed() ? -1 : 1);
//    			else
//    				return (r1.getName().compareTo(r2.getName()));
//    		}});
//    	
//    	System.out.println("creating essentiality matrix...");
//    	
//		// construct the transposed reaction incidence matrix multiplied by the local essentialities and row-normalized
//    	int m = reactionsList.size();
//    	SparseDoubleMatrix2D A = new SparseDoubleMatrix2D(m, m);
//		for (int i=0; i<m; i++) {
//			for (int j=0; j<m; j++) {
//				// set the local i,j to the local essentiality of reaction i to reaction j, multiplied by the damping factor
//				double essentiality = localEssentiality(reactionsList.get(i), reactionsList.get(j));
//				A.set(i, j, essentiality);
//			}
//			// normalize the row to sum up to 1
////			if (sum != 0) {
////				for (int j=0; j<m; j++)
////					A.set(i, j, A.get(i, j)/sum);
////			}
//		}
//		
//		if (debug) {
//			// print the original matrix
//			try {
//				BufferedWriter writer = new BufferedWriter(new FileWriter(file+".original", false));
//				for (int i=0; i<m; i++) {
//					for (int j=0; j<m; j++) {
//						writer.write(String.valueOf(A.get(i, j)));
//						writer.write(j < m-1 ? "\t" : "\n");
//					}
//				}
//				writer.close();
//				
//			} catch (IOException e) {
//				// TODO Auto-generated catch block
//				e.printStackTrace();
//			}
//		}
//		
//		// normalize colmuns and set the zero-columns to 1/m
//		for (int j=0; j<m; j++) {
////			if (inDegreeOf(reactionsList.get(j)) == 0) {
////				for (int i=0; i<m; i++)
////					A.set(i, j, 1/m);
////			}
//			double sum = 0;
//			for (int i=0; i<m; i++)
//				sum += A.get(i, j);
//			for (int i=0; i<m; i++) {
//				if (sum == 0)
//					A.set(i, j, 1/m);
//				else
//					A.set(i, j, A.get(i, j)/sum);
//			}
//		}
//		
//		if (debug) {
//			// print the matrix
//			try {
//				BufferedWriter writer = new BufferedWriter(new FileWriter(file, false));
//				for (int i=0; i<m; i++) {
//					for (int j=0; j<m; j++) {
//						writer.write(String.valueOf(A.get(i, j)));
//						writer.write(j < m-1 ? "\t" : "\n");
//					}
//				}
//				writer.close();
//				
//			} catch (IOException e) {
//				// TODO Auto-generated catch block
//				e.printStackTrace();
//			}
//		}
//		
//		System.out.print("Eigenvalue decomposition (colt)...");
//		long start = System.currentTimeMillis();
//		EigenvalueDecomposition decomposition = new EigenvalueDecomposition(A);
//		System.out.print((System.currentTimeMillis()-start)/1000+" seconds...");
//		
//		DoubleMatrix1D eigenvalues = decomposition.getRealEigenvalues();
//		DoubleMatrix2D eigenvectors = decomposition.getV();
//		
//		// get the eigenvector corresponding to the largest eigenvalue
//		System.out.print("getting dominant eigenvector...");
//		int largestIndex = -1;
//		double largest = Double.MIN_VALUE;
//		for (int i=0; i<eigenvalues.size(); i++) {
//			if (eigenvalues.get(i) > largest) {
//				largest = eigenvalues.get(i);
//				largestIndex = i;
//			}
//		}
//		System.out.println(eigenvalues.get(largestIndex)+" ["+largestIndex+"].");
//		
//		// collect the reaction names and corresponding eigenvector entries
//		DoubleMatrix1D vector = eigenvectors.viewColumn(largestIndex);
//		HashMap<String, Double> essentialities = new HashMap<String, Double>(m, 1f);
//		for (int i=0; i<m; i++) {
//			essentialities.put(reactionsList.get(i).getName(), vector.get(i));
//		}
//		
//		return essentialities;
//	}
	
	/**
	 * Calculates the number of possible substitutions for all reactions, i.e., the
	 * degree of the node representing this graph in the transition graph Sigma_G.
	 * 
	 * Assumes that the stoichiometry of any reaction is allowed to be updated.
	 * 
	 * @return Number of possible substitutions.
	 */
	public int getTransitionDegree(HashMap<ArrayList<Integer>, EquivalenceClass> classes, HashSet<Vertex> preserved) {
		int transitionDegree = 0;
		final int LEFT = 0, RIGHT = 0;
		
		for (Vertex reaction : getReactions()) {
			
			if (preserved.contains(reaction))
				continue;
			
			for (int side=0; side<=RIGHT; side++) {
				int degree = (side == LEFT ? inDegreeOf(reaction) : outDegreeOf(reaction));
				// retrieve the substrate/product edges of the reaction
				DefaultWeightedEdge[] edges = new DefaultWeightedEdge[degree];
				if (side == LEFT)
					incomingEdgesOf(reaction).toArray(edges);
				else
					outgoingEdgesOf(reaction).toArray(edges);
				// calculate the possible substitutions
				Substitutions substitutions = getSubstitutions(reaction, preserved, degree, side, edges, classes, false, hasCycle(reaction));
				// add the number of individual compound and pair substitutions
				transitionDegree += substitutions.substitutes.size();
				transitionDegree += (substitutions.substitutePairs.size()/2);
			}
		}
		
		return transitionDegree;
	}
	
	/**
	 * Returns the set containing all second neighboring vertices.
	 * The size of the set is the degree of the node in the corresponding
	 * undirected unipartite network.
	 * 
	 * @param v
	 * @return HashSet of neighboring vertices.
	 */
	public HashSet<Vertex> neighborsOf(Vertex v) {
		// TODO compare speed to direct check for equality with v
		HashSet<Vertex> neighbors = new HashSet<Vertex>(3*(inDegreeOf(v)+outDegreeOf(v)));
		for (Vertex neighbor : Graphs.neighborListOf(this, v))
			neighbors.addAll(Graphs.neighborListOf(this, neighbor));
		neighbors.remove(v);
//		for (Vertex v2 : neighbors)
//			System.out.print(v2.getName()+", ");
//		System.out.println();
		
		return neighbors;
	}
	
	/**
	 * Returns the set containing all second successor vertices.
	 * The size of the set is the out-degree of the node in the
	 * corresponding unipartite network.
	 * 
	 * @param v
	 * @return HashSet of successor vertices.
	 */
	public HashSet<Vertex> successorsOf(Vertex v) {
		// TODO compare speed to direct check for equality with v
		
		HashSet<Vertex> successors = new HashSet<Vertex>(3*outDegreeOf(v));
		for (Vertex successor : Graphs.successorListOf(this, v))
			successors.addAll(Graphs.successorListOf(this, successor));
		successors.remove(v);
		
		return successors;
	}
	
	/**
	 * Returns the set containing all second predecessor vertices.
	 * The size of the set is the in-degree of the node in the
	 * corresponding unipartite network.
	 * 
	 * @param v
	 * @return HashSet of predecessor vertices.
	 */
	public HashSet<Vertex> predecessorsOf(Vertex v) {
		// TODO compare speed to direct check for equality with v
		
		HashSet<Vertex> predecessors = new HashSet<Vertex>(3*inDegreeOf(v));
		for (Vertex predecessor : Graphs.predecessorListOf(this, v))
			predecessors.addAll(Graphs.predecessorListOf(this, predecessor));
		predecessors.remove(v);
		
		return predecessors;
	}
	
	/**
	 * Reads the deltaGf of compounds from a tab-separated file and stores the values
	 * with the compound vertices. 
	 * 
	 * @param file
	 * @throws IOException
	 */
	public void readDeltaG(String file, String logFile) throws IOException {
		BufferedReader reader = new BufferedReader(new FileReader(file));
		BufferedWriter logWriter = new BufferedWriter(new FileWriter(logFile, true));
		String line;
		int valid = 0, invalid = 0;
		
		// get all compartment strings (if there are none, a null element is returned)
		Set<String> compartments = getCompartments().keySet();
		
		while ((line = reader.readLine()) != null) {
			
			if (line.startsWith("#"))
				continue;
			
			String compoundName = line.substring(0, line.indexOf("\t")).trim();
			ArrayList<String> tokens = Utilities.parseTokens(line.substring(line.indexOf("\t")+1), "\t", false);
			String deltaGString = "";
			for (String token : tokens) {
				if (token.startsWith("D=")) {
					deltaGString = token.substring(2);
					break;
				}
			}
			
			try {
				Double deltaG = new Double(Double.parseDouble(deltaGString));
				// add the deltaG to the compound in every compartment
				for (String compartment : compartments) {
					Vertex compound = getCompound(compoundName, compartment);
					if (compound != null) {
						compound.setDeltaGf(deltaG);
						valid++;
					}
				}
			} catch (NumberFormatException e) {
				invalid++;
				logWriter.write("Invalid deltaG for "+compoundName+": "+deltaGString+".\n");
			}
		}
		
		String message = "Read "+valid+" deltaG values, "+invalid+" invalid lines.";
		logWriter.write(message+"\n");
		System.out.println(message);
		
		reader.close();
		logWriter.close();
	}
	
	/**
	 * Calculates the sum of deltaGr over all reactions.
	 * 
	 * For performance reasons the result is allowed to be slightly imprecise (use
	 * of primitive types). However, the corresponding float representation should be precise.
	 * Use Double.floatValue() to reproduce exact results.
	 * 
	 * @return Sum of deltaGr.
	 */
	public Double getDeltaGn() {
		Double deltaGn = 0d;
		
		// calculate the reactions' deltaG
		for (Vertex reaction : getReactions()) {
			// reversible reactions are skipped as they do not contribute to deltaGn
			if (reaction.reversedReaction() != null)
				continue;
			Double deltaGr =  getDeltaGr(reaction, true);
			if (deltaGr == null)
				continue;
			// add the deltaGr of the reaction
			deltaGn += deltaGr;
		}
		
//		if (deltaGn > 0) {
//			for (Vertex reaction : getReactions()) {
//				Utilities.printReaction(this, reaction);
//			}
//		}
		
		return deltaGn;
	}
	
	/**
	 * Counts the number of reactions containing only compounds
	 * with a known deltaGf.
	 * 
	 * @return Number of reactions with a deltaGf.
	 */
	public int validDeltaGr() {
		int counter = 0;
		for (Vertex reaction : getReactions()) {
			// reversible reactions are skipped as they do not contribute to deltaGn
			if (reaction.reversedReaction() == null && getDeltaGr(reaction, true) != null)
				counter++;
		}
		
		return counter;
	}
	
	/**
	 * Calculates the deltaGr of a reaction by summing over the negative deltaGf of
	 * substrates and the positive deltaGf of products, multiplied by the stoichiometric
	 * coefficients.
	 * 
	 * For performance reasons the result is allowed to be slightly imprecise (use
	 * of primitive types). However, the corresponding float representation should be precise.
	 * Use Double.floatValue() to reproduce exact results.
	 * 
	 * If reversible==true, the deltaGr of reversible reactions is considered 0. Otherwise,
	 * the deltaGr of the reaction vertex is returned, independent of whether the vertex
	 * is the forward or reversed direction of a reversible reaction.
	 * 
	 * @param reaction
	 * @param reversible
	 * @return deltaGr of the reaction.
	 */
	public Double getDeltaGr(Vertex reaction, boolean reversible) {
		Double deltaGr = 0d;
		
		if (!reaction.getType() == Vertex.REACTION)
			throw new IllegalArgumentException("Cannot invoke method with a Vertex not of type Vertex.REACTION.");
		
		// reversible reactions have a deltaGr of 0
		if (reversible && reaction.reversedReaction() != null)
			return deltaGr;
		
		// subtract the substrates' deltaG
		for (Vertex substrate : Graphs.predecessorListOf(this, reaction)) {
			Double deltaG = substrate.getDeltaGf();
			if (deltaG != null)
				deltaGr -= (deltaG*getEdgeWeight(getEdge(substrate, reaction)));
			else
				return null;
		}
		// add the products' deltaG
		for (Vertex product : Graphs.successorListOf(this, reaction)) {
			Double deltaG = product.getDeltaGf();
			if (deltaG != null)
				deltaGr += (deltaG*getEdgeWeight(getEdge(reaction, product)));
			else
				return null;
		}
		
		return deltaGr;
	}
	
	/**
	 * Returns a map of compartment strings and vertex sets. Each vertex set contains
	 * the compounds from the corresponding compartment string.
	 *  
	 * @return HashMap of compartment strings and vertex sets.
	 */
	public HashMap<String,HashSet<Vertex>> getCompartments() {
		HashMap<String,HashSet<Vertex>> compartments = new HashMap<String,HashSet<Vertex>>();
		
		for (Vertex compound : getCompounds()) {
			HashSet<Vertex> compartment = compartments.get(compound.getCompartment());
			if (compartment == null) {
				compartment = new HashSet<Vertex>();
				compartments.put(compound.getCompartment(), compartment);
			}
			compartment.add(compound);
		}
		
		return compartments;
	}
	
	/**
	 * Calculate the sample space and substitutability class sizes for individual and pair substitutions.
	 * 
	 * Note that the pair substitutability classes also contain implicit pairs, i.e., pairwise linearly dependent individual compounds.
	 * 
	 * Note that the sample space is not affected by the set of preserved vertices.
	 * 
	 * @param classes
	 * @param substitutabilityFile
	 * @throws IOException
	 */
	public void substitutability(HashMap<ArrayList<Integer>, EquivalenceClass> classes, String substitutabilityFile) throws IOException {
		boolean debug = false;
		BigDecimal singleRadix = BigDecimal.ONE, doubleRadix = BigDecimal.ONE;
		long singleExponent = 0, doubleExponent = 0;
		int maxDistance = 0;
		BufferedWriter singleWriter = new BufferedWriter(new FileWriter(substitutabilityFile+".single.sizes", false));
		BufferedWriter doubleWriter = new BufferedWriter(new FileWriter(substitutabilityFile+".double.sizes", false));
		BufferedWriter singleSumWriter = new BufferedWriter(new FileWriter(substitutabilityFile+".reactions.single.sizes", false));
		BufferedWriter doubleSumWriter = new BufferedWriter(new FileWriter(substitutabilityFile+".reactions.double.sizes", false));	
		final int LEFT = 0, RIGHT = 1;
		
		for (Vertex reaction : getReactions()) {
			HashMap<String,HashSet<Vertex>> compartments = getCompartments(reaction);
			boolean[][] substitutable = new boolean[2][Math.max(inDegreeOf(reaction), outDegreeOf(reaction))];
			boolean[][] requiredUpdates = new boolean[2][Math.max(inDegreeOf(reaction), outDegreeOf(reaction))];
			Arrays.fill(requiredUpdates[0], true);
			Arrays.fill(requiredUpdates[1], true);
			int singleSum = 0, doubleSum = 0;
			
			// collect the equivalence classes of substrates and products
			for (int side=LEFT; side<=RIGHT; side++) {
				HashSet<EquivalenceClass> singleClasses = new HashSet<EquivalenceClass>();
				HashSet<EquivalenceClass> doubleClasses = new HashSet<EquivalenceClass>();
				List<Vertex> neighbours = (side==LEFT? Graphs.predecessorListOf(this, reaction) : Graphs.successorListOf(this, reaction));
				
				// print the substitutabilities: numbers of mass equivalent compounds (pairs with solvable stoichiometry)
				for (int i=0; i<neighbours.size(); i++) {
					if (neighbours.get(i).getMass() != null) {
						
						// individual compound substitutions
						EquivalenceClass singleClass = classes.get(Equivalence.normalize(neighbours.get(i).getMass()));
						
						// check if this compound is substitutable
						if (singleClass.getNames().size() > 1) {
							substitutable[side][i] = true;
							// check if we would need a stoichiometry update, as only one is allowed per reaction
							for (int[] mass : singleClass.getMasses()) {
								int[] solve = solveStoichiometry(mass, (int)getEdgeWeight(getEdge(side==LEFT?neighbours.get(i):reaction, side==LEFT?reaction:neighbours.get(i))), neighbours.get(i).getMass());
								if (solve != null && solve[1] == 1) {
									requiredUpdates[side][i] = false;
									break;
								}
							}
						}
						// number of individual compounds substituions = size of mass equivalence class -1
						singleSum += (singleClass.getNames().size()-1);
						singleWriter.write((singleClass.getNames().size()-1)+"\t");
						// calculate the sample space: double product of |e| over |phi(e)|
						if (singleClasses.add(singleClass)) {
							long e = singleClass.getNames().size();
							long phi = 0;
							// count the compounds which are already a substrate/product
							for (String name : singleClass.getNames()) {
								for (String compartment : compartments.keySet()) {
									if (side==LEFT ? containsEdge(getCompound(name, compartment), reaction) : containsEdge(reaction, getCompound(name, compartment)))
										phi++;
								}
							}
							if (debug && phi != 1)
								System.out.println("Reaction "+reaction.getName()+" has mass equivalent "+(side==LEFT?"substrates.":"products."));
							// multiply with the binomial coefficient
							singleRadix = singleRadix.multiply(new BigDecimal(Utilities.binomialCoefficient(e, phi)));
						}
						
						// pair substitutions
						for (int j=i+1; j<neighbours.size(); j++) {
							int solvable = 0, substitutions = 0;
							if (neighbours.get(j).getMass() != null) {
								EquivalenceClass doubleClass = classes.get(Equivalence.normalize(Equivalence.sumMasses(neighbours.get(i).getMass(), neighbours.get(j).getMass())));
								Vertex compound1 = neighbours.get(i);
								Vertex compound2 = neighbours.get(j);
								int[] mass1 = compound1.getMass();
								int[] mass2 = compound2.getMass();
								int weight1 = (int)(side==LEFT ? getEdgeWeight(getEdge(neighbours.get(i), reaction)) : getEdgeWeight(getEdge(reaction, neighbours.get(i))));
								int weight2 = (int)(side==LEFT ? getEdgeWeight(getEdge(neighbours.get(j), reaction)) : getEdgeWeight(getEdge(reaction, neighbours.get(j))));
								HashMap<String[],int[][]> pairs = doubleClass.getPairs();
								for (String[] pair : pairs.keySet()) {
									// a double substitution is possible if the stoichiometry is solvable
									int[] solve = solveStoichiometry(pairs.get(pair)[0], pairs.get(pair)[1], weight1, weight2, mass1, mass2, false);
									if (solve != null) {
										solvable++;
										for (String compartment1 : compartments.keySet()) {
											for (String compartment2 : compartments.keySet()) {
												if ((side==LEFT && !containsEdge(getCompound(pair[0], compartment1), reaction) && !containsEdge(getCompound(pair[1], compartment2), reaction))
														|| (side==RIGHT && !containsEdge(reaction, getCompound(pair[0], compartment1)) && !containsEdge(reaction, getCompound(pair[1], compartment2)))) {
													substitutions++;
													substitutable[side][i] = true;
													substitutable[side][j] = true;
													if (solve[2] == 1) {
														requiredUpdates[side][i] = false;
														requiredUpdates[side][j] = false;
													}
												}
											}
										}
									}
								}
								if (solvable > 0) {
									// the number of pair substitutions
									doubleSum += substitutions;
									doubleWriter.write((substitutions)+"\t");
									if (doubleClasses.add(doubleClass)) {
										// calculate the sample space: double product of |e| over |phi(e)|
										long e = solvable;
										long phi = 0;
										// count the pairs which have an existing substrate/product 
										for (String[] pair : pairs.keySet()) {
											int[] solve = solveStoichiometry(pairs.get(pair)[0], pairs.get(pair)[1], weight1, weight2, mass1, mass2, false);
											if (solve != null) {
												for (String compartment1 : compartments.keySet()) {
													for (String compartment2 : compartments.keySet()) {
														if (side==LEFT && containsEdge(getCompound(pair[0], compartment1), reaction) && containsEdge(getCompound(pair[1], compartment2), reaction))
															phi++;
														else if (side==RIGHT && containsEdge(reaction, getCompound(pair[0], compartment1)) && containsEdge(reaction, getCompound(pair[1], compartment2)))
															phi++;
													}
												}
											}
										}
										if (debug && phi != 1)
											System.out.println("Reaction "+reaction.getName()+" has mass equivalent "+(side==LEFT?"substrate":"product")+" pairs. (phi="+phi+")");
										// multiply with the binomial coefficient
										doubleRadix = doubleRadix.multiply(new BigDecimal(Utilities.binomialCoefficient(e, phi)));
									}
								}
							}
							if (solvable == 0)
								doubleWriter.write("0\t");
						}
					} else {
						singleWriter.write("0\t");
					}
				}
			}
			
			// print the sum of substitutability class sizes for the reaction
			singleSumWriter.write(singleSum+"\t");
			doubleSumWriter.write(doubleSum+"\t");
			
			// determine the maximum number of differences between original and randomized:
			// the number of substrates and products with valid unequal substitutes
			boolean updated = false;
			for (int side=LEFT; side<=RIGHT; side++) {
				for (int i=0; i<substitutable[side].length; i++) {
					if (substitutable[side][i] && (!updated || !requiredUpdates[side][i]))
						maxDistance++;
					if (requiredUpdates[side][i])
						updated = true;
				}
			}
		}
		
		singleWriter.write("\n");
		doubleWriter.write("\n");
		singleSumWriter.write("\n");
		doubleSumWriter.write("\n");
		
		// reduce sample spaces to a readable form
		while (singleRadix.floatValue()/10 >= 1) {
			singleRadix = singleRadix.divide(BigDecimal.TEN);
			singleExponent++;
		}
		while (doubleRadix.floatValue()/10 >= 1) {
			doubleRadix = doubleRadix.divide(BigDecimal.TEN);
			doubleExponent++;
		}
		
		String message = "Single sample space: "+singleRadix.floatValue()+"E+"+singleExponent+"\n"
		+"Double sample space (apx.): "+doubleRadix.floatValue()+"E+"+doubleExponent+"\n";
		System.out.print(message);
		System.out.println("Maximum distance (number substitutable substrates and products): "+maxDistance);
		
		singleWriter.close();
		doubleWriter.close();
		singleSumWriter.close();
		doubleSumWriter.close();
		
	}
	
	/**************************
	 * Randomization methods. *
	 **************************/

	/**
	 * <p>
	 * Performs mass balanced randomization on the graph by perturbing single compounds and pairs.
	 * In a randomized reaction, substrates and products, and pairs thereof, are replaced by 
	 * substitutes from the corresponding mass equivalence class.
	 * 
	 * <p>
	 * The perturbations preserve the reaction degree with respect to compounds, i.e., the number
	 * of unique substrates/products is not changed. Mass balance is preserved: any reaction has the
	 * same numbers of chemical species on each side after perturbation. Generating duplicate reactions
	 * in the network is avoided.
	 * 
	 * <p>
	 * If compartments==true, then compounds are only substituted within the same compartment.
	 * In addition, reactions which connect compartments and reactions with in- or out-degree of zero are skipped. 
	 * 
	 * <p>
	 * If preserveStrongComponents==true, then the sizes of strongly connected components are preserved in
	 * the following way: any substitution which changes the size of the component of the original
	 * compound is skipped. In that way, the creation of 'orphane' or 'dead end' metabolites is avoided.    
	 * 
	 * @param classes Mass equivalence classes of the compounds.
	 * @param preserved A set of vertices (compounds or reactions) which are not randomized.
	 * @param p if p<1, then each reaction is only perturbed with probability p.
	 * @param depth factor indicating randomization strength. 1 indicates default values (see below). 
	 * @param iterative if true, then each reaction is randomized (deg*deg+deg)/2 times, otherwise |V_r|*avgDeg^2 reaction sides are chosen at random and perturbed once. 
	 * reactions are randomized once.
	 * @param logFile 
	 * @return The ratio of modified reactions in the network if logFile != null, null otherwise.
	 */
	public BigDecimal randomize(MetabolicGraph originalGraph, HashMap<ArrayList<Integer>, EquivalenceClass> classes, HashSet<Vertex> preserved, float p, boolean iterative, float depth, String deltaGFile, String substitutabilityFile, boolean append, String logFile) throws IOException {
		boolean debug = false, debug2 = false, log = false, randomWalk = false, first = true;
		BigDecimal ratio = null;
		final int LEFT = 0;
		final int RIGHT = 1;
		int skipped = 0, steps = Integer.MAX_VALUE, distance = 0, validDeltaGr = 0, transitions = 0;
		long reactionTime = 0, visitTime = 0;
		// the name array is necessary only for non-iterative mode
		String[] reactions = new String[getReactions().size()];
		getReactionNames().toArray(reactions);
		HashSet<Vertex> unmodifiableReactions = new HashSet<Vertex>(reactions.length);
		
		if (p <= 0 || p > 1)
			throw new IllegalArgumentException("Invalid probability: must be 0<p<=1");
		
		// remember original reactions with cycles, allow cycles to be generated only for those reactions 
		HashSet<Vertex> cycleReactions = new HashSet<Vertex>();
		for (Vertex reaction : getReactions()) {
			if (hasCycle(reaction))
				cycleReactions.add(reaction);
		}
		
		// log-file
		BufferedWriter logWriter = null;
		if (logFile != null) {
			logWriter = new BufferedWriter(new FileWriter(logFile, false));
			logWriter.write("# "+this.version+"\n");
			log = true;
		}
		// write original deltaGn and distance 0 to files
		Double avgDeltaGr = null;
		BufferedWriter deltaGRunWriter = null, deltaGDistanceWriter = null;
		if (deltaGFile != null) {
			validDeltaGr = validDeltaGr();
			avgDeltaGr = getDeltaGn()/(double)validDeltaGr; // do not use originalGraph here because we may continue randomization (MetabolicGraphs randomize)
			deltaGRunWriter = new BufferedWriter(new FileWriter(deltaGFile+".run", append));
			deltaGRunWriter.write(String.valueOf(avgDeltaGr.floatValue()));
			distance = distanceTo(originalGraph); // this is only necessary if we continue randomization (MetabolicGraphs randomize)
			deltaGDistanceWriter = new BufferedWriter(new FileWriter(deltaGFile+".distance", append));
			deltaGDistanceWriter.write(String.valueOf(distance));
		}
		BufferedWriter substitutabilityWriter = null;
		if (substitutabilityFile != null) {
			substitutabilityWriter = new BufferedWriter(new FileWriter(substitutabilityFile, append));
		}
		if (debug)
			Utilities.checkBalance(this);
		
		Random random = new Random();
		
		// repetitions to observe unmodifiable reactions
//		HashSet<Vertex> unmodifiableReactions = new HashSet<Vertex>();
//		for (int repeat = 0; repeat<100; repeat++) {
		
		// In iterative mode each reaction is randomized (deg*deg+deg)/2 times. In non-iterative mode the network is perturbed |V_r|*avgDeg^2 times.
		double avgDegree;
		int t = iterative ? reactions.length : (int)Math.ceil(depth*(reactions.length*(avgDegree=averageReactionDegree().doubleValue())*avgDegree));
		
		if (!append) {
			if (iterative) {
				avgDegree = averageReactionDegree().doubleValue();
				System.out.println("Iterative mode, depth="+depth+": apx. "+((int)Math.ceil(depth*((double)(avgDegree*avgDegree+avgDegree)/(double)2)*reactions.length*2))+" perturbations ((deg*deg+deg)/2 per reaction side).");
			} else
				System.out.println("Non-iterative mode: "+t+" perturbations.");
		}
		
		if (randomWalk) {
			steps = 0;
			t = -1;
		}
		
		for (int repeat = 0; repeat<t || steps<10000; repeat++) {
			// randomize a reaction
			Double deltaGr = null;
			int distanceR = 0;
			reactionTime = System.currentTimeMillis();
			Vertex reaction = iterative ? getReaction(reactions[repeat]) : getReaction(reactions[random.nextInt(reactions.length)]);
			
			if (preserved.contains(reaction)) {
				skipped++;
				continue;
			}
			
			boolean[] modifiable = {false, false};
			boolean[] modified = {false, false};
			
			Vertex duplicate = isDuplicate(reaction);
			boolean wasDuplicate = (duplicate != null);
			boolean isDuplicate = wasDuplicate;
			
			if (log && wasDuplicate) {
				System.out.println("WARNING: duplicate reactions found: "+reaction.getName()+" and "+duplicate.getName());
				logWriter.write("WARNING: duplicate reactions found: "+reaction.getName()+" and "+duplicate.getName()+"\n");
			}
			
			// skip import/export reactions, and transport reactions if we have compartments
			if ((this.compartments && getCompartments(reaction).keySet().size() > 1) || inDegreeOf(reaction) == 0 || outDegreeOf(reaction) == 0) {
				if (log)
					logWriter.write("Unmodifiable transport/import/export reaction: "+reaction.getName()+"\n");
				skipped++;
				continue;
			}
			
			if (debug)
				System.out.println(reaction.getName()+(wasDuplicate?" was duplicate with "+duplicate.getName():""));
			
			// skip with probability 1-p (include in modified ratio)
			if (p < 1 && random.nextFloat() >= p)
				continue;
			
			// remember deltaGr and previous distance
			if (deltaGFile != null)
				deltaGr = getDeltaGr(reaction, true);
			distanceR = distance(reaction, originalGraph);
			
			do {
				
				// perturb left and right side of the reaction
				for (int side=0; side<=RIGHT && (iterative || side<1); side++) {
					// in non-iterative mode choose one reaction side at random
					if (!iterative)
						side = random.nextInt(2);
					
					// default: perform (d^2+d)/2 perturbations (round up) per reaction side, where d is degree of the reaction side
					int degree = (side == LEFT ? inDegreeOf(reaction) : outDegreeOf(reaction));
					int iterations = iterative ? (int)Math.ceil(depth*(double)(degree*degree+degree)/(double)2) : 1;
					
					Substitutions substitutions = null;
					
					// retrieve the substrate/product edges of the reaction
					DefaultWeightedEdge[] edges = new DefaultWeightedEdge[degree];
					if (side == LEFT)
						incomingEdgesOf(reaction).toArray(edges);
					else
						outgoingEdgesOf(reaction).toArray(edges);
					
					if (debug)
						System.out.println((side == LEFT ? "Left:" : "Right:")+" degree: "+degree+", iterations: "+iterations+", probability p="+p);
					
					for (int iteration=0; iteration<iterations; iteration++) {
						
						// skip generating substitutions if the reaction was not modified in the previous iteration
						if (iteration == 0 || modified[side]) {
							
							// determine the possible substitutions
							substitutions = getSubstitutions(reaction, preserved, degree, side, edges, classes, false, cycleReactions.contains(reaction));
							modifiable[side] = substitutions.modifiable;
						}

						if (debug && (iteration == 0 || modified[side]))
							Utilities.printSubstitutions(this, reaction, classes);
						
						// skip iterations if the side is unmodifiable
						if (!modifiable[side]) {
							if (debug)
								System.out.println("Unmodifiable: "+reaction.getName()+(side==LEFT?"[left]":"[right]"));
							break;
						}
						
						// draw a random number corresponding to a substitution
						int numSubstitutions = substitutions.substitutes.size() + (substitutions.substitutePairs.size()/2);
						int randomIndex = random.nextInt(numSubstitutions);
						
						// apply the chosen substitution
						if (randomIndex < substitutions.substitutes.size()) {
							// perturb a single compound
							int edgeIndex = substitutions.edgeIndices.get(randomIndex);
							DefaultWeightedEdge edge = edges[edgeIndex];
							Vertex compound = (side == LEFT ? getEdgeSource(edge) : getEdgeTarget(edge));
							Vertex substitute = substitutions.substitutes.get(randomIndex);
							int weight = (int)getEdgeWeight(edge);
							int[] solve = substitutions.stoichiometry.get(randomIndex);
							
							// skip if the substitute is the same as the original
							if (!substitute.equals(compound)) {
								if (debug)
									System.out.println(Utilities.DELIMITER_COEFFICIENT_START+weight+Utilities.DELIMITER_COEFFICIENT_END+" "+compound.getName()+"\t--->\t"+Utilities.DELIMITER_COEFFICIENT_START+solve[0]+Utilities.DELIMITER_COEFFICIENT_END+" "+substitute.getName());
								// substitute the old edge by the new edge, weighted by the new stoichiometry 
								removeEdge(edge);
								if (side == LEFT) {
									edges[edgeIndex] = addEdge(substitute, reaction);
									setEdgeWeight(edges[edgeIndex], solve[0]);
								} else {
									edges[edgeIndex] = addEdge(reaction, substitute);
									setEdgeWeight(edges[edgeIndex], solve[0]);
								}
								if (solve[1] > 1) {
									if (debug) {
										System.out.println("Single update: "+reaction.getName()+" * "+solve[1]);
										System.out.println(Utilities.DELIMITER_COEFFICIENT_START+weight+Utilities.DELIMITER_COEFFICIENT_END+" "+compound.getName()+"\t--->\t"+Utilities.DELIMITER_COEFFICIENT_START+solve[0]+Utilities.DELIMITER_COEFFICIENT_END+" "+substitute.getName());
									}
									// update the coefficients of the remaining substrates and products
									for (DefaultWeightedEdge e : edgesOf(reaction)) {
										if (!e.equals(edges[edgeIndex]))
											setEdgeWeight(e, getEdgeWeight(e)*solve[1]);
									}
								}
								modified[side] = true;
							} else {
								modified[side] = false;
							}
							
						} else {
							// perturb a pair of compounds
							randomIndex -= substitutions.substitutes.size();
							int edgeIndex1 = substitutions.edgePairIndices.get(randomIndex*2);
							int edgeIndex2 = substitutions.edgePairIndices.get(randomIndex*2+1);
							int[] solve = substitutions.stoichiometryPairs.get(randomIndex);
							DefaultWeightedEdge edge1 = edges[edgeIndex1];
							DefaultWeightedEdge edge2 = edges[edgeIndex2];
							Vertex compound1 = (side == LEFT ? getEdgeSource(edge1) : getEdgeTarget(edge1));
							Vertex compound2 = (side == LEFT ? getEdgeSource(edge2) : getEdgeTarget(edge2));
							Vertex substitute1 = substitutions.substitutePairs.get(randomIndex*2);
							Vertex substitute2 = substitutions.substitutePairs.get(randomIndex*2+1);
							
							int[] weights = {(int)getEdgeWeight(edge1), (int)getEdgeWeight(edge2)};
//							stoichiometryTime1 = System.currentTimeMillis();
//							int[] stoichiometry = solveStoichiometry(substitute1.getMass(), substitute2.getMass(), weights[0], weights[1], compound1.getMass(), compound2.getMass());
//							stoichiometryTime2 += (System.currentTimeMillis()-stoichiometryTime1);
							
							// skip if the substitutes are the same as the originals
							if (!substitute1.equals(compound1) && !substitute1.equals(compound2) || !substitute2.equals(compound1) && !substitute2.equals(compound2)) {
								if (debug)
									System.out.println(Utilities.DELIMITER_COEFFICIENT_START+(int)getEdgeWeight(edge1)+Utilities.DELIMITER_COEFFICIENT_END+" "+compound1.getName()+" + "+Utilities.DELIMITER_COEFFICIENT_START+(int)getEdgeWeight(edge2)+Utilities.DELIMITER_COEFFICIENT_END+" "+compound2.getName()+"\t--->\t"+Utilities.DELIMITER_COEFFICIENT_START+solve[0]+Utilities.DELIMITER_COEFFICIENT_END+" "+substitute1.getName()+" + "+Utilities.DELIMITER_COEFFICIENT_START+solve[1]+Utilities.DELIMITER_COEFFICIENT_END+" "+substitute2.getName());
								
								// substitute the old edges by the new edges, weighted by the new stoichiometry
								removeEdge(edge1);
								removeEdge(edge2);
								if (side == LEFT) {
									edges[edgeIndex1] = addEdge(substitute1, reaction);
									edges[edgeIndex2] = addEdge(substitute2, reaction);
									setEdgeWeight(edges[edgeIndex1], solve[0]);
									setEdgeWeight(edges[edgeIndex2], solve[1]);
								} else {
									edges[edgeIndex1] = addEdge(reaction, substitute1);
									edges[edgeIndex2] = addEdge(reaction, substitute2);
									setEdgeWeight(edges[edgeIndex1], solve[0]);
									setEdgeWeight(edges[edgeIndex2], solve[1]);
								}
								if (solve[2] > 1) {
									if (debug) {
										System.out.println("Double update: "+reaction.getName()+" * "+solve[2]);
										System.out.println(Utilities.DELIMITER_COEFFICIENT_START+weights[0]+Utilities.DELIMITER_COEFFICIENT_END+" "+compound1.getName()+" + "+Utilities.DELIMITER_COEFFICIENT_START+weights[1]+Utilities.DELIMITER_COEFFICIENT_END+" "+compound2.getName()+"\t--->\t"+Utilities.DELIMITER_COEFFICIENT_START+solve[0]+Utilities.DELIMITER_COEFFICIENT_END+" "+substitute1.getName()+" + "+Utilities.DELIMITER_COEFFICIENT_START+solve[1]+Utilities.DELIMITER_COEFFICIENT_END+" "+substitute2.getName());
									}
									// update the coefficients of the remaining substrates and products
									for (DefaultWeightedEdge e : edgesOf(reaction)) {
										if (!e.equals(edges[edgeIndex1]) && !e.equals(edges[edgeIndex2]))
											setEdgeWeight(e, getEdgeWeight(e)*solve[2]);
									}
								}
								modified[side] = true;
							} else {
								modified[side] = false;
							}
						}
						
						// reset the stoichiometry to the smallest possible integer
						if (modified[side])
							fixStoichiometry(reaction);
						
						// check the difference in number of substitutions
						if (substitutabilityFile != null && modified[side] && transitions < 10000) {
							Substitutions newSubstitutions = getSubstitutions(reaction, preserved, degree, side, edges, classes, false, cycleReactions.contains(reaction));
							int newNumSubstitutions = newSubstitutions.substitutes.size() + (newSubstitutions.substitutePairs.size()/2);
							substitutabilityWriter.write((first?"":"\t")+(numSubstitutions-newNumSubstitutions));
							transitions++;
							first = false;
						}
						
						// increase the visits of the generated network
						// exclude self-edges (unmodified network)
						if (randomWalk && modified[side]) {
							steps++;
							long time2 = System.currentTimeMillis();
							visit();
							visitTime += (System.currentTimeMillis()-time2);
						}
						
						if (debug2) {
							System.out.println(isDuplicate(reaction) != null ? "duplicate":"");
							Utilities.printReaction(this, reaction, true, true);
						}
					}
				}
			
			// avoid infinite loop: repeat if the reaction was not a duplicate but is now.
				isDuplicate = (!wasDuplicate && isDuplicate(reaction) != null);
			} while (isDuplicate);
			
			// add the new distance to the original reaction
			int distanceDiff = (distance(reaction, originalGraph) - distanceR);
			distance += distanceDiff;
			// test the distance
//			int distanceG = distanceTo(originalGraph);
//			if (distanceG != distance)
//				System.out.println("distanceTo: "+distanceG+", distance: "+distance);
			
			if (deltaGFile != null) {
				// calculate the new deltaGn according to deltaGrNew
				// reversible reactions are skipped as they do not contribute to deltaGn
				if (reaction.reversedReaction() == null) {
					Double deltaGrNew = getDeltaGr(reaction, true);
					if (deltaGr != null && deltaGrNew == null) {
						// subtract the difference to the average
						validDeltaGr--;
						avgDeltaGr -= ((deltaGr-avgDeltaGr)/(double)validDeltaGr);
					} else if (deltaGr == null && deltaGrNew != null) {
						// add the new deltaGr and calculate the new average
						avgDeltaGr *= (double)validDeltaGr;
						validDeltaGr++;
						avgDeltaGr += deltaGrNew;
						avgDeltaGr /= (double)validDeltaGr;
					} else if (deltaGr != null && deltaGrNew != null) {
						// add the new deltaGr
						avgDeltaGr += ((deltaGrNew-deltaGr)/(double)validDeltaGr);
					}
				}
				// write (every tenth) deltaGn and distance to files
//				if (repeat % 10 == 9) {
					deltaGRunWriter.write("\t"+avgDeltaGr.floatValue());
					deltaGDistanceWriter.write("\t"+distance);
//				}
			}
			
			if (iterative && !modifiable[LEFT] && !modifiable[RIGHT]) {
				if (unmodifiableReactions.add(reaction) && log)
					logWriter.write("Unmodifiable reaction: "+reaction.getName()+"\n");
//				if (unmodifiableReactions.add(reaction) && repeat>0)
//					System.out.println("New unmodifiable reaction: "+reaction.getName());
			}
			
			reactionTime = (System.currentTimeMillis()-reactionTime);
			if (reactionTime > 10000)
				System.out.println("Reaction "+reaction.getName()+" took "+reactionTime/1000+" seconds.");
		}
//		}
		
		// determine rounding errors
		if (debug) {
			Double fullDeltaGn = getDeltaGn()/validDeltaGr();
			System.out.println("Average DeltaGr error: "+(fullDeltaGn-avgDeltaGr));
		}
		
		// print the sojourn times
		if (randomWalk) {
			int min = Integer.MAX_VALUE, max = -1, original = -1;
			for (MetabolicGraph graph : this.visits.keySet()) {
				int visited = this.visits.get(graph).intValue();
				max = (max < visited ? visited : max);
				min = (min > visited ? visited : min);
				if (graph.compare(originalGraph))
					original = visited;
				System.out.print(visited+" ");
			}
			System.out.println();
			System.out.println(steps+" steps, original: "+original+", min: "+min+", max: "+max);
			System.out.println("visit time: "+visitTime+" ms.");
		}
		
		if (log) {
			// print the modified reactions ratio
			HashSet<Vertex> modifiedReactions = new HashSet<Vertex>(reactions.length);
			for (Vertex reaction : getReactions()) {
				if (distance(reaction, originalGraph) != 0) {
					if (unmodifiableReactions.contains(reaction)) {
						Utilities.printReaction(this, reaction, false, false);
						throw new RuntimeException("Unmodifiable reaction "+reaction.getName()+" has distance "+distance(reaction, originalGraph)+".");
					}
					modifiedReactions.add(reaction);
				}
			}
			ratio = new BigDecimal(String.valueOf(modifiedReactions.size())).divide(new BigDecimal(String.valueOf(reactions.length)), 6, RoundingMode.HALF_UP);
			String message = "";
			if (p == 1 && iterative)
				message += (unmodifiableReactions.size()+" unmodifiable reactions ("+((float)(unmodifiableReactions.size()*100)/(float)reactions.length)+"%)\n");
			message += "Modified "+modifiedReactions.size()+" ("+ratio.multiply(new BigDecimal("100")).floatValue()+"% of randomized reactions), skipped "+skipped+" times.\n";
			logWriter.write(message);
			System.out.print(message);
			logWriter.close();
		}
		if (deltaGFile != null) {
			deltaGRunWriter.write("\n");
			deltaGDistanceWriter.write("\n");
			deltaGRunWriter.close();
			deltaGDistanceWriter.close();
		}
		if (substitutabilityFile != null) {
			substitutabilityWriter.write("\n");
			substitutabilityWriter.close();
		}
		
		if (debug)
			Utilities.checkBalance(this);
		
		return ratio;
	}
	
	/**
	 * Calculate the possible substitutions for the given side of the reaction. Each substitution consists of 3-tuples 
	 * of (pairs of) compound vertices, stoichiometric coefficients, and the (pairs of) edge indices corresponding
	 * to a unique original substrate or product (pair).
	 * 
	 * @param reaction
	 * @param preservedCompounds
	 * @param degree
	 * @param side
	 * @param edges
	 * @param classes
	 * @param updated
	 * @return
	 */
	protected Substitutions getSubstitutions(Vertex reaction, HashSet<Vertex> preservedCompounds, int degree, int side, final DefaultWeightedEdge[] edges, HashMap<ArrayList<Integer>, EquivalenceClass> classes, boolean allowIsolated, boolean allowCycle) {
		boolean debug = false, time = false;
		final int LEFT = 0, RIGHT = 1;
		long substitutesTime1 = 0, substitutesTime2 = 0, stoichiometryTime1 = 0, stoichiometryTime2 = 0;
		
		if (time)
			substitutesTime1 = System.currentTimeMillis();
		
		 Substitutions substitutions = new Substitutions(degree);
		
		// determine the possible substitutes: mass equivalent compounds and pairs, which are not yet on the same side of the reaction,
		// have an integer solution for the stoichiometric coefficients, exist in the same compartment, and do not result in isolated
		// compound nodes
		for (int i=0; i<degree; i++) {
			
			// individual substitutes
			Vertex compound = (side == LEFT ? getEdgeSource(edges[i]) : getEdgeTarget(edges[i]));
			
			if (preservedCompounds.contains(compound))
				continue;
			
			// skip compounds that would result in an isolated node when substituted
			// here we could also test for a blocked compound (in-degree or out-degree 0)
			boolean isolated = !allowIsolated && (reaction.reversedReaction()==null ? inDegreeOf(compound)+outDegreeOf(compound) <= 1 : inDegreeOf(compound)+outDegreeOf(compound) <= 2);
			
			if (compound.getMass() != null && !isolated) {
				EquivalenceClass eqClass = classes.get(Equivalence.normalize(compound.getMass()));
				for (int k=0; k<eqClass.getMasses().size(); k++) {
					// if the graph has compartments get the substitute from the same compartment 
					Vertex substitute = getCompound(eqClass.getName(k), (this.compartments ? compound.getCompartment() : null));
					if (substitute == null || preservedCompounds.contains(substitute))
						continue;
					// any of the following conditions must be true for a substitute:
					// (1) the substitute is the same as the original compound, or
					// (2) allowCycle is false and the substitute is not already on any side of the reaction, or 
					// (3) the substitute is not already on the same side of the reaction as the original compound.
					if (substitute.equals(compound) || (!allowCycle && !hasEdge(substitute, reaction)) || (allowCycle && side==LEFT && !containsEdge(substitute, reaction)) || (allowCycle && side==RIGHT && !containsEdge(reaction, substitute))) {
						// skip if the stoichiometry factor is too big
						int[] solve = solveStoichiometry(substitute.getMass(), (int)getEdgeWeight(edges[i]), compound.getMass());
						if (solve != null) {
							// if this is the second substitute for the same compound then this reaction is modifiable
							if (!substitutions.modifiable && substitutions.edgeIndices.size()>0 && substitutions.edgeIndices.get(substitutions.edgeIndices.size()-1) == i)
								substitutions.modifiable = true;
							substitutions.addSingle(substitute, solve, i);
						}
					} else if (debug)
						// phosphate forms not in the network or edge already exists
						System.out.println("Compound not substitutable in "+reaction.getName()+": "+compound.getName()+Utilities.DELIMITER_COMPOUND_COMPARTMENT+compound.getCompartment()+" <---> "+substitute.getName());
				}
			}
			
			// substitute pairs
			for (int j=i+1; j<degree; j++) {
				
				Vertex compound1 = (side == LEFT ? getEdgeSource(edges[i]) : getEdgeTarget(edges[i]));
				Vertex compound2 = (side == LEFT ? getEdgeSource(edges[j]) : getEdgeTarget(edges[j]));
				
				if (preservedCompounds.contains(compound1) || preservedCompounds.contains(compound2))
					continue;
				
				String compartment1 = (this.compartments ? compound1.getCompartment() : null);
				String compartment2 = (this.compartments ? compound2.getCompartment() : null);
				int weight1 = (int)getEdgeWeight(edges[i]), weight2 = (int)getEdgeWeight(edges[j]);
				int[] mass1 = compound1.getMass(), mass2 = compound2.getMass();
				
				if (compound1.getMass() != null && compound2.getMass() != null) {
					
					EquivalenceClass eqClass = classes.get(Equivalence.normalize(Equivalence.sumMasses(compound1.getMass(), compound2.getMass())));
					HashMap<String[], int[][]> pairs = eqClass.getPairs();
					
					for (String[] pair : pairs.keySet()) {
						// if the graph has compartments get the substitutes from the same compartment
						Vertex substitute1 = getCompound(pair[0], compartment1);
						Vertex substitute2 = getCompound(pair[1], compartment2);
						
						if (substitute1 == null || substitute2 == null || preservedCompounds.contains(substitute1) || preservedCompounds.contains(substitute2))
							continue;
						
						// skip compounds that would result in an isolated node when substituted
						boolean isolated1 = !compound1.equals(substitute1) && !compound1.equals(substitute2)
								&& (reaction.reversedReaction()==null ? inDegreeOf(compound1)+outDegreeOf(compound1) <= 1 : inDegreeOf(compound1)+outDegreeOf(compound1) <= 2);
						boolean isolated2 = !compound2.equals(substitute1) && !compound2.equals(substitute2)
								&& (reaction.reversedReaction()==null ? inDegreeOf(compound2)+outDegreeOf(compound2) <= 1 : inDegreeOf(compound2)+outDegreeOf(compound2) <= 2);
						if (!allowIsolated && (isolated1 || isolated2))
							continue;
						
						// any of the following conditions must be true for each substitute:
						// (1) the substitute is the same as the original compound, or
						// (2) allowCycle is false and the substitute is not already on any side of the reaction, or 
						// (3) the substitute is not already on the same side of the reaction as the original compound.
						if (((substitute1.equals(compound1) || substitute1.equals(compound2) || (!allowCycle && !hasEdge(substitute1, reaction)) || (allowCycle && side==LEFT && !containsEdge(substitute1, reaction)) || (allowCycle && side==RIGHT && !containsEdge(reaction, substitute1))))
								&& (substitute2.equals(compound1) || substitute2.equals(compound2) || (!allowCycle && !hasEdge(substitute2, reaction)) || (allowCycle && side==LEFT && !containsEdge(substitute2, reaction)) || (allowCycle && side==RIGHT && !containsEdge(reaction, substitute2)))) {
							// check for solvable stoichiometry
							if (time)
								stoichiometryTime1 = System.currentTimeMillis();
							int[] solve = solveStoichiometry(pairs.get(pair)[0], pairs.get(pair)[1], weight1, weight2, mass1, mass2, time);
							if (time)
								stoichiometryTime2 += (System.currentTimeMillis()-stoichiometryTime1);
							if (solve != null) {
								// if this is the second substitute pair for the same compound pair then this reaction is modifiable
								if (!substitutions.modifiable && substitutions.edgePairIndices.size()>1 && substitutions.edgePairIndices.get(substitutions.edgePairIndices.size()-2)==i && substitutions.edgePairIndices.get(substitutions.edgePairIndices.size()-1)==j)
									substitutions.modifiable = true;
								substitutions.addPair(substitute1, substitute2, solve, i, j);
							} else if (debug) {
								// print non-trivial unsolvable stoichiometric equation systems
//								System.out.println("Unsolvable: {"+(int)getEdgeWeight(edges[i])+"} "+compound1.getName()+" + {"+(int)getEdgeWeight(edges[j])+"} "+compound2.getName()+" ===> "+pair[0]+" + "+pair[1]+" in "+reaction.getName()+"["+(side==LEFT?"left":"right")+"]");
								Utilities.printEquationSystem(pairs.get(pair)[0], pairs.get(pair)[1], (int)getEdgeWeight(edges[i]), (int)getEdgeWeight(edges[j]), compound1.getMass(), compound2.getMass(), false);
							}
						} else if (debug)
							// phosphate forms not in the network or edge already exists
							System.out.println("Compounds not substitutable in "+reaction.getName()+": "+compound1.getName()+Utilities.DELIMITER_COMPOUND_COMPARTMENT+compound1.getCompartment()+" + "+compound2.getName()+Utilities.DELIMITER_COMPOUND_COMPARTMENT+compound2.getCompartment()+" <---> "+pair[0]+" + "+pair[1]);
					}
					if (debug && !(solveStoichiometry(compound1.getMass(), compound2.getMass(), (int)getEdgeWeight(edges[i]), (int)getEdgeWeight(edges[j]), compound1.getMass(), compound2.getMass(), false) != null))
						throw new RuntimeException("Compounds "+compound1.getName()+" + "+compound2.getName()+" unsolvable for themselves in "+reaction.getName());
				}
			}
		}
		
		// alternative way to determine modifiability of a reaction, independent of the order of substitutions.
//		HashSet<Integer> edgeIndices = new HashSet<Integer>(substitutions.edgeIndices);
//		if (edgeIndices.size() != substitutions.edgeIndices.size()) {
//			substitutions.modifiable = true;
//		} else {
//			// for pair substitutions, check if the same edge index pair occurs twice
//			HashSet<Long> primeFactors = new HashSet<Long>();
//			for (Iterator<Integer> it = substitutions.edgePairIndices.iterator(); it.hasNext();) {
//				int edgePairIndex1 = it.next();
//				int edgePairIndex2 = it.next(); // assumes to always have pairs of indices
//				Long primeFactor = (long)(Math.pow(2,edgePairIndex1)*Math.pow(3,edgePairIndex2));
//				if (primeFactors.contains(primeFactor))
//					substitutions.modifiable = true;
//				primeFactors.add(primeFactor);
//			}
//		}
		
		if (time) {
			substitutesTime2 += (System.currentTimeMillis()-substitutesTime1);
			System.out.println("Time substitutabilities: "+substitutesTime2+", time stoichiometry: "+stoichiometryTime2);
		}
			
		
		return substitutions;
	}
	
	/**
	 * Increments the visits of this graph node in the transition graph.
	 * 
	 * For simplicity the visits are not stored by overriding equals()
	 * and hashCode(). Instead, all existing visited graphs are checked for
	 * identity by calling compare() (this is slow for medium sized graphs). If
	 * no identical graph exists, a new clone of this graph is added with 1 visit.
	 * 
	 */
	private void visit() {
		if (this.visits == null)
			visits = new HashMap<MetabolicGraph, Integer>(getReactions().size()*getReactions().size());
		
		// increment the existing visits for this graph
		for (MetabolicGraph graph : visits.keySet()) {
			if (this.compareEdges(graph)) {
				visits.put(graph, visits.get(graph).intValue()+1);
				return;
			}
		}
		
		// add a new copy with 1 visit
		visits.put(this.clone(), 1);
		return;
	}
	
	/**
	 * Writes each possible single and pair substitution of the stoichiometric matrix
	 * of the original network to tab-separated files. Does not modify the network.
	 * 
	 * Each line of the files corresponds to one substitution:
	 * 
	 * reaction D=deltaGr d=diff old_compound(s) new_compound(s) (i j s)+
	 * 
	 * where deltaGr is the DeltaGr of the original reaction, and diff is the difference
	 * in DeltaGr between the original and the new reaction. (i j s)+ is any number of triplets,
	 * with i the row index (compound), j the column index (reaction), and s the new
	 * coefficient (i.e., [i,j] is set to s).
	 * 
	 * If reversible==true, then the substitution indices correspond to the stoichiometric matrix
	 * including reversible reactions as two columns, one for each direction (corresponding
	 * to a call of {@link MetabolicGraph#stoichiometricMatrix(String,boolean,boolean,boolean,boolean)}
	 * with reversible==true). Otherwise, the indices correspond to the stoichiometric matrix
	 * excluding reversed directions of reversible reactions (corresponding to a call of
	 * {@link MetabolicGraph#stoichiometricMatrix(String,boolean,boolean,boolean,boolean)}
	 * with reversible==false).
	 * 
	 * Note: the order of substitutions is not the same as in {@link MetabolicGraph#equationSubstitutions(MetabolicGraph,HashMap,HashSet,String,boolean)}.
	 * 
	 * TODO include reaction equations from equationSubstitutions in output file.
	 * 
	 * @param classes
	 * @param outputFile
	 * @param doubles
	 * @param reversible
	 * @see MetabolicGraph#equationSubstitutions(MetabolicGraph,HashMap,HashSet,String,boolean)
	 * @throws IOException
	 */
	public void matrixSubstitutions(HashMap<ArrayList<Integer>, EquivalenceClass> classes, HashSet<Vertex> preserved, String outputFile, boolean doubles, boolean reversible) throws IOException {
		boolean debug = false;
		final int LEFT = 0, RIGHT = 1;
		BufferedWriter singlesWriter = new BufferedWriter(new FileWriter(outputFile+".singles"));
		BufferedWriter doublesWriter = null;
		if (doubles)
			doublesWriter = new BufferedWriter(new FileWriter(outputFile+".doubles"));
		
		Collection<Vertex> reactionsSet = getReactions();
		Collection<Vertex> compoundsSet = getCompounds();
		
		// sort the compounds by name and compartment
		ArrayList<Vertex> compoundsList = new ArrayList<Vertex>(compoundsSet);
    	Collections.sort(compoundsList, new VertexComparator());
		// sort the reactions by name (and implicitly by reversedness)
    	ArrayList<Vertex> reactionsList = new ArrayList<Vertex>(reactionsSet);
    	Collections.sort(reactionsList, new VertexComparator());
    	
	    int j = 0;
		for (Vertex reaction : reactionsList) {
			
			// skip preserved, transport, and import/export reactions
			if (!preserved.contains(reaction) && (!hasCompartments() || getCompartments(reaction).keySet().size() < 2) && inDegreeOf(reaction) != 0 && outDegreeOf(reaction) != 0) {
			
				for (int side=LEFT; side<=RIGHT; side++) {
					
					int degree = (side == LEFT ? inDegreeOf(reaction) : outDegreeOf(reaction));
					// retrieve the substrate/product edges of the reaction
					DefaultWeightedEdge[] edges = new DefaultWeightedEdge[degree];
					if (side == LEFT)
						incomingEdgesOf(reaction).toArray(edges);
					else
						outgoingEdgesOf(reaction).toArray(edges);
					
					// get all possible substitutions
					Substitutions substitutions = getSubstitutions(reaction, preserved, degree, side, edges, classes, true, true);
					
					// print single substitutions
					for (int k=0; k<substitutions.substitutes.size(); k++) {
						
						DefaultWeightedEdge edge = edges[substitutions.edgeIndices.get(k)];
						Vertex compound = (side == LEFT ? getEdgeSource(edge) : getEdgeTarget(edge));
						Vertex substitute = substitutions.substitutes.get(k);
						int[] solve = substitutions.stoichiometry.get(k);
						
						// skip if the substitute is the same as the original
						if (!substitute.equals(compound)) {
							
							// get index of the compound to be substituted
							int i_old = compoundsList.indexOf(compound);
							// get the old compound's new coefficient multiplied by stoichiometry factor: unequals 0, iff the compound exists also on the opposite side of the reaction
							int s_old;
							if (side == LEFT)
								s_old = (getEdge(reaction, compound) != null) ? solve[1]*(int)getEdgeWeight(getEdge(reaction, compound)) : 0;
							else 
								s_old = (getEdge(compound, reaction) != null) ? -solve[1]*(int)getEdgeWeight(getEdge(compound, reaction)) : 0;
							// get index of the new substitute
							int i_new = compoundsList.indexOf(substitute);
							// add new coefficient and any existing coefficient from the opposite side of the reaction, multiplied by stoichiometry factor
							DefaultWeightedEdge e = (side == LEFT ? getEdge(reaction, substitute) : getEdge(substitute, reaction));
							int s_opposite = (e == null ? 0 : (side == LEFT ? (int)getEdgeWeight(e) : -(int)getEdgeWeight(e)));
							int s_new = solve[1] * s_opposite + (side == LEFT ? -solve[0] : solve[0]);
							
							// get the reaction's old deltaGr
							Double deltaGr = getDeltaGr(reaction, false);
							String deltaGrString = (deltaGr == null ? "NA" : String.valueOf(deltaGr.floatValue()));
							// calculate the difference in deltaGr after substitution
							Double deltaGdiff = getDeltaGDifference(reaction, side, compound, substitute, solve);
							String deltaGdiffString = (deltaGdiff == null ? "NA" : String.valueOf(deltaGdiff.floatValue()));
							
							// get the original reaction equation
							String equation = getReactionEquation(this, reaction);
							// clone the graph and get the corresponding reaction, substitute and edge
							MetabolicGraph clone = this.clone();
							Vertex newReaction = clone.getReaction(reaction.getName());
							Vertex newCompound = clone.getCompound(compound.getName(), compound.getCompartment());
							Vertex newSubstitute = clone.getCompound(substitute.getName(), substitute.getCompartment());
							DefaultWeightedEdge newEdge = (side == LEFT ? clone.getEdge(newCompound, newReaction) : clone.getEdge(newReaction, newCompound));
							// apply the substitution to the clone
							clone.removeEdge(newEdge);
							DefaultWeightedEdge newAddedEdge;
							if (side == LEFT) {
								newAddedEdge = clone.addEdge(newSubstitute, newReaction);
								clone.setEdgeWeight(newAddedEdge, solve[0]);
							} else {
								newAddedEdge = clone.addEdge(newReaction, newSubstitute);
								clone.setEdgeWeight(newAddedEdge, solve[0]);
							}
							if (solve[1] > 1) {
								// update the coefficients of the remaining substrates and products
								for (DefaultWeightedEdge e2 : clone.edgesOf(newReaction)) {
									if (!e2.equals(newAddedEdge))
										clone.setEdgeWeight(e2, clone.getEdgeWeight(e2)*solve[1]);
								}
							}
							// get the new reaction equation
							String newEquation = getReactionEquation(clone, newReaction);
							
							// print <reaction> <old_equation> <deltaGr> <new_equation> <diff> 
							singlesWriter.write(reaction.getName()+"\t"+equation+"\tD="+deltaGrString+"\t"+newEquation+"\td="+deltaGdiffString);
							// print <old compound> <new compound> and first 2 triplets: [i_old,j] = s_old and [i_new,j] = s_new
							singlesWriter.write("\t"+compound.getName()+(hasCompartments() ? Utilities.DELIMITER_COMPOUND_COMPARTMENT+compound.getCompartment() : "")
									+"\t"+substitute.getName()+(hasCompartments() ? Utilities.DELIMITER_COMPOUND_COMPARTMENT+substitute.getCompartment() : "")+"\t"+i_old+"\t"+j+"\t"+s_old+"\t"+i_new+"\t"+j+"\t"+s_new);
							// next 2 triplets: reversed reaction [i_old,j+1] = -s_old and [i_new,j+1] = -s_new
							if (reversible && reaction.reversedReaction() != null)
								singlesWriter.write("\t"+i_old+"\t"+(j+1)+"\t"+(-s_old)+"\t"+i_new+"\t"+(j+1)+"\t"+(-s_new));
							
							if (debug) {
								// test s_old
								int s_old_test;
								if (side == LEFT)
									s_old_test = solve[1] * (getEdge(reaction, compound) != null ? (int)getEdgeWeight(getEdge(reaction, compound)) : 0);
								else
									s_old_test = -solve[1] * (getEdge(compound, reaction) != null ? (int)getEdgeWeight(getEdge(compound, reaction)) : 0);
								if (s_old != s_old_test)
									System.out.println("s_old error: "+s_old+" != "+s_old_test);
								// test s_new
								int s_new_test;
								if (side == LEFT)
									s_new_test = -solve[0] + solve[1] * (getEdge(reaction, substitute) != null ? (int)getEdgeWeight(getEdge(reaction, substitute)) : 0);
								else
									s_new_test = solve[0] - solve[1] * (getEdge(substitute, reaction) != null ? (int)getEdgeWeight(getEdge(substitute, reaction)) : 0);
								if (s_new != s_new_test)
									System.out.println("s_new error: "+s_new+" != "+s_new_test);
							}
							
							// if the stoichiometry needs an update, add the triplets for each remaing substrate and product of the reaction
							if (solve[1] > 1) {
								for (Vertex substrate : Graphs.predecessorListOf(this, reaction)) {
									// skip the original and substitute, multiply each remaining [i,j] by -solve[1]
									if (!substitute.equals(substrate) && !compound.equals(substrate)) {
										i_old = compoundsList.indexOf(substrate);
										s_new = -(int)getEdgeWeight(getEdge(substrate, reaction)) * solve[1];
										singlesWriter.write("\t"+i_old+"\t"+j+"\t"+s_new);
										if (reversible && reaction.reversedReaction() != null)
											singlesWriter.write("\t"+i_old+"\t"+(j+1)+"\t"+(-s_new));
									}
								}
								for (Vertex product : Graphs.successorListOf(this, reaction)) {
									// skip the original and substitute, multiply each remaining [i,j] by solve[1]
									if (!substitute.equals(product) && !compound.equals(product)) {
										i_old = compoundsList.indexOf(product);
										s_new = (int)getEdgeWeight(getEdge(reaction, product)) * solve[1];
										singlesWriter.write("\t"+i_old+"\t"+j+"\t"+s_new);
										if (reversible && reaction.reversedReaction() != null)
											singlesWriter.write("\t"+i_old+"\t"+(j+1)+"\t"+(-s_new));
									}
								}
							}
							singlesWriter.write("\n");
						}
					}
					
					if (doubles) {
						// print double substitutions
						for (int k=0; k<substitutions.substitutePairs.size()/2; k++) {
							
							DefaultWeightedEdge edge1 = edges[substitutions.edgePairIndices.get(k*2)];
							DefaultWeightedEdge edge2 = edges[substitutions.edgePairIndices.get(k*2+1)];
							Vertex compound1 = (side == LEFT ? getEdgeSource(edge1) : getEdgeTarget(edge1));
							Vertex compound2 = (side == LEFT ? getEdgeSource(edge2) : getEdgeTarget(edge2));
							Vertex substitute1 = substitutions.substitutePairs.get(k*2);
							Vertex substitute2 = substitutions.substitutePairs.get(k*2+1);
							int[] solve = substitutions.stoichiometryPairs.get(k);
							
							// skip if the substitutes are the same as the originals
							if ((!substitute1.equals(compound1) && !substitute1.equals(compound2) || !substitute2.equals(compound1) && !substitute2.equals(compound2))) {
								
								// get indices of the compounds to be substituted 
								int i1_old = compoundsList.indexOf(compound1), i2_old = compoundsList.indexOf(compound2);
								// get the old compound's new coefficients multiplied by stoichiometry factor: unequals 0, iff the compounds exist also on the opposite side of the reaction
								int s1_old, s2_old;
								if (side == LEFT) {
									s1_old = (getEdge(reaction, compound1) != null) ? solve[2]*(int)getEdgeWeight(getEdge(reaction, compound1)) : 0;
									s2_old = (getEdge(reaction, compound2) != null) ? solve[2]*(int)getEdgeWeight(getEdge(reaction, compound2)) : 0;
								} else { 
									s1_old = (getEdge(compound1, reaction) != null) ? -solve[2]*(int)getEdgeWeight(getEdge(compound1, reaction)) : 0;
									s2_old = (getEdge(compound1, reaction) != null) ? -solve[2]*(int)getEdgeWeight(getEdge(compound2, reaction)) : 0;
								}
								// get indices of the new substitutes
								int i1_new = compoundsList.indexOf(substitute1), i2_new = compoundsList.indexOf(substitute2);
								// add new coefficients and any existing coefficients from the opposite side of the reaction, multiplied by stoichiometry factor
								DefaultWeightedEdge e1 = (side == LEFT ? getEdge(reaction, substitute1) : getEdge(substitute1, reaction));
								DefaultWeightedEdge e2 = (side == LEFT ? getEdge(reaction, substitute2) : getEdge(substitute2, reaction));
								int s1_opposite = (e1 == null ? 0 : (side == LEFT ? (int)getEdgeWeight(e1) : -(int)getEdgeWeight(e1)));
								int s2_opposite = (e2 == null ? 0 : (side == LEFT ? (int)getEdgeWeight(e2) : -(int)getEdgeWeight(e2)));							
								int s1_new = solve[2] * s1_opposite + (side == LEFT ? -solve[0] : solve[0]);
								int s2_new = solve[2] * s2_opposite + (side == LEFT ? -solve[1] : solve[1]);
								
								// get the reaction's old deltaGr
								Double deltaGr = getDeltaGr(reaction, false);
								String deltaGrString = (deltaGr == null ? "NA" : String.valueOf(deltaGr.floatValue()));
								// calculate the difference in deltaGr after substitution
								Double deltaGdiff = getDeltaGDifference(reaction, side, compound1, compound2, substitute1, substitute2, solve);
								String deltaGdiffString = (deltaGdiff == null ? "NA" : String.valueOf(deltaGdiff.floatValue()));
								
								// get the original reaction equation
								String equation = getReactionEquation(this, reaction);
								// clone the graph and get the corresponding reaction, substitutes and edges
								MetabolicGraph clone = this.clone();
								Vertex newReaction = clone.getReaction(reaction.getName());
								Vertex newCompound1 = clone.getCompound(compound1.getName(), compound1.getCompartment());
								Vertex newCompound2 = clone.getCompound(compound2.getName(), compound2.getCompartment());
								Vertex newSubstitute1 = clone.getCompound(substitute1.getName(), substitute1.getCompartment());
								Vertex newSubstitute2 = clone.getCompound(substitute2.getName(), substitute2.getCompartment());
								DefaultWeightedEdge newEdge1 = (side == LEFT ? clone.getEdge(newCompound1, newReaction) : clone.getEdge(newReaction, newCompound1));
								DefaultWeightedEdge newEdge2 = (side == LEFT ? clone.getEdge(newCompound2, newReaction) : clone.getEdge(newReaction, newCompound2));
								// apply the substitution to the clone
								clone.removeEdge(newEdge1);
								clone.removeEdge(newEdge2);
								DefaultWeightedEdge newAddedEdge1, newAddedEdge2;
								if (side == LEFT) {
									newAddedEdge1 = clone.addEdge(newSubstitute1, newReaction);
									newAddedEdge2 = clone.addEdge(newSubstitute2, newReaction);
									clone.setEdgeWeight(newAddedEdge2, solve[0]);
									clone.setEdgeWeight(newAddedEdge2, solve[1]);
								} else {
									newAddedEdge1 = clone.addEdge(newReaction, newSubstitute1);
									newAddedEdge2 = clone.addEdge(newReaction, newSubstitute2);
									clone.setEdgeWeight(newAddedEdge1, solve[0]);
									clone.setEdgeWeight(newAddedEdge2, solve[1]);
								}
								if (solve[2] > 1) {
									// update the coefficients of the remaining substrates and products
									for (DefaultWeightedEdge e : clone.edgesOf(newReaction)) {
										if (!e.equals(newAddedEdge1) && !e.equals(newAddedEdge2))
											clone.setEdgeWeight(e, clone.getEdgeWeight(e)*solve[2]);
									}
								}
								// get the new reaction equation
								String newEquation = getReactionEquation(clone, newReaction);
								
								// print <reaction> <old_equation> <deltaGr> <new_equation> <diff> 
								doublesWriter.write(reaction.getName()+"\t"+equation+"\tD="+deltaGrString+"\t"+newEquation+"\td="+deltaGdiffString);
								// print <old compound1> <old compound2> <new compound1> <new compound2> and first 4 triplets: [i1_old,j]=s1_old, [i2_old,j]=s2_old, [i1_new,j]=s1_new, [i2_new,j]=s2_new
								doublesWriter.write("\t"+compound1.getName()+(hasCompartments() ? Utilities.DELIMITER_COMPOUND_COMPARTMENT+compound1.getCompartment() : "")+"\t"+compound2.getName()+(hasCompartments() ? Utilities.DELIMITER_COMPOUND_COMPARTMENT+compound2.getCompartment() : "")
										+"\t"+substitute1.getName()+(hasCompartments() ? Utilities.DELIMITER_COMPOUND_COMPARTMENT+substitute1.getCompartment() : "")+"\t"+substitute2.getName()+(hasCompartments() ? Utilities.DELIMITER_COMPOUND_COMPARTMENT+substitute2.getCompartment() : "")
										+"\t"+i1_old+"\t"+j+"\t"+s1_old+"\t"+i2_old+"\t"+j+"\t"+s2_old
										+"\t"+i1_new+"\t"+j+"\t"+s1_new+"\t"+i2_new+"\t"+j+"\t"+s2_new);
								// next 4 triplets: reversed reaction [i1_old,j+1]=-s1_old, [i2_old,j+1]=-s2_old, [i1_new,j+1]=-s1_new, and [i2_new,j+1]=-s2_new
								if (reversible && reaction.reversedReaction() != null)
									doublesWriter.write("\t"+i1_old+"\t"+(j+1)+"\t"+(-s1_old)+"\t"+i2_old+"\t"+(j+1)+"\t"+(-s2_old)+"\t"+i1_new+"\t"+(j+1)+"\t"+(-s1_new)+"\t"+i2_new+"\t"+(j+1)+"\t"+(-s2_new));
								
								// if the stoichiometry needs an update, add the triplets for each remaing substrate and product of the reaction
								if (solve[2] > 1) {
									for (Vertex substrate : Graphs.predecessorListOf(this, reaction)) {
										// skip the original compounds and substitutes and multiply each other [i,j] by -solve[2]
										if (!compound1.equals(substrate) && !compound2.equals(substrate) && !substitute1.equals(substrate) && !substitute2.equals(substrate)) {
											i1_old = compoundsList.indexOf(substrate);
											s1_new = -(int)getEdgeWeight(getEdge(substrate, reaction)) * solve[2];
											doublesWriter.write("\t"+i1_old+"\t"+j+"\t"+s1_new);
											if (reversible && reaction.reversedReaction() != null)
												doublesWriter.write("\t"+i1_old+"\t"+(j+1)+"\t"+(-s1_new));
										}
									}
									for (Vertex product : Graphs.successorListOf(this, reaction)) {
										// skip the original compounds and substitutes and multiply each other [i,j] by solve[2]
										if (!compound1.equals(product) && !compound2.equals(product) && !substitute1.equals(product) && !substitute2.equals(product)) {
											i1_old = compoundsList.indexOf(product);
											s1_new = (int)getEdgeWeight(getEdge(reaction, product)) * solve[2];
											doublesWriter.write("\t"+i1_old+"\t"+j+"\t"+s1_new);
											if (reversible && reaction.reversedReaction() != null)
												doublesWriter.write("\t"+i1_old+"\t"+(j+1)+"\t"+(-s1_new));
										}
									}
								}
								doublesWriter.write("\n");
							}
						}
					}
				}
			}
			j++;
			// increment twice if a reversible reaction was printed
			if (reversible && reaction.reversedReaction() != null)
				j++;
		}
		
		singlesWriter.close();
		if (doubles)
			doublesWriter.close();
	}
	
	/**
	 * Writes each possible single and pair substitution of the reaction equations
	 * of the original network to tab-separated files. Does not modify the network.
	 * 
	 * Each line of the files corresponds to one substitution:
	 * 
	 * reaction old_equation deltaGr new_equation diff 
	 * 
	 * where old_equation is the reaction equation of the original reaction, deltaGr is the
	 * DeltaGr of the original reaction, new_equation is the equation of the substituted reaction,
	 * and diff is the difference in DeltaGr between the original and the new reaction.
	 * 
	 * Note: the order of substitutions is not the same as in {@link MetabolicGraph#matrixSubstitutions(HashMap,HashSet,String,boolean,boolean)}.
	 * 
	 * @param originalGraph
	 * @param classes
	 * @param outputFile
	 * @param doubles
	 * @see MetabolicGraph#matrixSubstitutions(HashMap,HashSet,String,boolean,boolean)
	 * @throws IOException
	 */
	public void equationSubstitutions(MetabolicGraph originalGraph, HashMap<ArrayList<Integer>, EquivalenceClass> classes, HashSet<Vertex> preserved, String outputFile, boolean doubles) throws IOException {
		final int LEFT = 0, RIGHT = 1;
		BufferedWriter singlesWriter = new BufferedWriter(new FileWriter(outputFile+".singles"));
		BufferedWriter doublesWriter = null;
		if (doubles)
			doublesWriter = new BufferedWriter(new FileWriter(outputFile+".doubles"));
		
		Collection<Vertex> reactionsSet = getReactions();
		Collection<Vertex> compoundsSet = getCompounds();
		
		// sort the compounds by name and compartment
		ArrayList<Vertex> compoundsList = new ArrayList<Vertex>(compoundsSet);
    	Collections.sort(compoundsList, new VertexComparator());
		// sort the reactions by name (and implicitly by reversedness)
    	ArrayList<Vertex> reactionsList = new ArrayList<Vertex>(reactionsSet);
    	Collections.sort(reactionsList, new VertexComparator());
	    
		for (Vertex reaction : reactionsList) {
			
			// skip preserved, transport, and import/export reactions
			if (!preserved.contains(reaction) && getCompartments(reaction).keySet().size() < 2 && inDegreeOf(reaction) != 0 && outDegreeOf(reaction) != 0) {
			
				for (int side=LEFT; side<=RIGHT; side++) {
					
					int degree = (side == LEFT ? inDegreeOf(reaction) : outDegreeOf(reaction));
					// retrieve the substrate/product edges of the reaction
					DefaultWeightedEdge[] edges = new DefaultWeightedEdge[degree];
					if (side == LEFT)
						incomingEdgesOf(reaction).toArray(edges);
					else
						outgoingEdgesOf(reaction).toArray(edges);
					
					// get all possible substitutions
					Substitutions substitutions = getSubstitutions(reaction, preserved, degree, side, edges, classes, true, true);
					
					// print single substitutions
					for (int k=0; k<substitutions.substitutes.size(); k++) {
						
						DefaultWeightedEdge edge = edges[substitutions.edgeIndices.get(k)];
						Vertex compound = (side == LEFT ? getEdgeSource(edge) : getEdgeTarget(edge));
						Vertex substitute = substitutions.substitutes.get(k);
						int[] solve = substitutions.stoichiometry.get(k);
						
						// skip if the substitute is the same as the original
						if (!substitute.equals(compound)) {
							
							// get the reaction's old deltaGr
							Double deltaGr = getDeltaGr(reaction, false);
							String deltaGrString = (deltaGr == null ? "NA" : String.valueOf(deltaGr.floatValue()));
							// calculate the difference in deltaGr after substitution
							Double deltaGdiff = getDeltaGDifference(reaction, side, compound, substitute, solve);
							String deltaGdiffString = (deltaGdiff == null ? "NA" : String.valueOf(deltaGdiff.floatValue()));
							
							// get the original reaction equation
							String equation = getReactionEquation(this, reaction);
							// clone the graph and get the corresponding reaction, substitute and edge
							MetabolicGraph clone = this.clone();
							Vertex newReaction = clone.getReaction(reaction.getName());
							Vertex newCompound = clone.getCompound(compound.getName(), compound.getCompartment());
							Vertex newSubstitute = clone.getCompound(substitute.getName(), substitute.getCompartment());
							DefaultWeightedEdge newEdge = (side == LEFT ? clone.getEdge(newCompound, newReaction) : clone.getEdge(newReaction, newCompound));
							// apply the substitution to the clone
							clone.removeEdge(newEdge);
							DefaultWeightedEdge newAddedEdge;
							if (side == LEFT) {
								newAddedEdge = clone.addEdge(newSubstitute, newReaction);
								clone.setEdgeWeight(newAddedEdge, solve[0]);
							} else {
								newAddedEdge = clone.addEdge(newReaction, newSubstitute);
								clone.setEdgeWeight(newAddedEdge, solve[0]);
							}
							if (solve[1] > 1) {
								// update the coefficients of the remaining substrates and products
								for (DefaultWeightedEdge e : clone.edgesOf(newReaction)) {
									if (!e.equals(newAddedEdge))
										clone.setEdgeWeight(e, clone.getEdgeWeight(e)*solve[1]);
								}
							}
							// get the new reaction equation
							String newEquation = getReactionEquation(clone, newReaction);
							
							// this line was used for matching matrixSubstitutions and equationSubstitutions files
							// print <reaction> <D=deltaGr> <d=deltaGDiff> <old compound> <new compound> and first 2 triplets: [i_old,j] = s_old and [i_new,j] = s_new
//							singlesWriter.write(reaction.getName()+"\tD="+deltaGrString+"\td="+deltaGdiffString+"\t"+compound.getName()+Utilities.DELIMITER_COMPOUND_COMPARTMENT+compound.getCompartment()
//									+"\t"+substitute.getName()+Utilities.DELIMITER_COMPOUND_COMPARTMENT+substitute.getCompartment()+"\t");
							
							// print <reaction> <old_equation> <deltaGr> <new_equation> <deltaGr> <diff> 
							singlesWriter.write(reaction.getName()+"\t"+equation+"\tD="+deltaGrString+"\t"+newEquation+"\td="+deltaGdiffString+"\n");
						}
					}
					
					if (doubles) {
						// print double substitutions
						for (int k=0; k<substitutions.substitutePairs.size()/2; k++) {
							
							DefaultWeightedEdge edge1 = edges[substitutions.edgePairIndices.get(k*2)];
							DefaultWeightedEdge edge2 = edges[substitutions.edgePairIndices.get(k*2+1)];
							Vertex compound1 = (side == LEFT ? getEdgeSource(edge1) : getEdgeTarget(edge1));
							Vertex compound2 = (side == LEFT ? getEdgeSource(edge2) : getEdgeTarget(edge2));
							Vertex substitute1 = substitutions.substitutePairs.get(k*2);
							Vertex substitute2 = substitutions.substitutePairs.get(k*2+1);
							int[] solve = substitutions.stoichiometryPairs.get(k);
							
							// skip if the substitutes are the same as the originals
							if ((!substitute1.equals(compound1) && !substitute1.equals(compound2) || !substitute2.equals(compound1) && !substitute2.equals(compound2))) {
								
								// get the reaction's old deltaGr
								Double deltaGr = getDeltaGr(reaction, false);
								String deltaGrString = (deltaGr == null ? "NA" : String.valueOf(deltaGr.floatValue()));
								// calculate the difference in deltaGr after substitution
								Double deltaGdiff = getDeltaGDifference(reaction, side, compound1, compound2, substitute1, substitute2, solve);
								String deltaGdiffString = (deltaGdiff == null ? "NA" : String.valueOf(deltaGdiff.floatValue()));
								
								// get the original reaction equation
								String equation = getReactionEquation(this, reaction);
								// clone the graph and get the corresponding reaction, substitutes and edges
								MetabolicGraph clone = this.clone();
								Vertex newReaction = clone.getReaction(reaction.getName());
								Vertex newCompound1 = clone.getCompound(compound1.getName(), compound1.getCompartment());
								Vertex newCompound2 = clone.getCompound(compound2.getName(), compound2.getCompartment());
								Vertex newSubstitute1 = clone.getCompound(substitute1.getName(), substitute1.getCompartment());
								Vertex newSubstitute2 = clone.getCompound(substitute2.getName(), substitute2.getCompartment());
								DefaultWeightedEdge newEdge1 = (side == LEFT ? clone.getEdge(newCompound1, newReaction) : clone.getEdge(newReaction, newCompound1));
								DefaultWeightedEdge newEdge2 = (side == LEFT ? clone.getEdge(newCompound2, newReaction) : clone.getEdge(newReaction, newCompound2));
								// apply the substitution to the clone
								clone.removeEdge(newEdge1);
								clone.removeEdge(newEdge2);
								DefaultWeightedEdge newAddedEdge1, newAddedEdge2;
								if (side == LEFT) {
									newAddedEdge1 = clone.addEdge(newSubstitute1, newReaction);
									newAddedEdge2 = clone.addEdge(newSubstitute2, newReaction);
									clone.setEdgeWeight(newAddedEdge2, solve[0]);
									clone.setEdgeWeight(newAddedEdge2, solve[1]);
								} else {
									newAddedEdge1 = clone.addEdge(newReaction, newSubstitute1);
									newAddedEdge2 = clone.addEdge(newReaction, newSubstitute2);
									clone.setEdgeWeight(newAddedEdge1, solve[0]);
									clone.setEdgeWeight(newAddedEdge2, solve[1]);
								}
								if (solve[2] > 1) {
									// update the coefficients of the remaining substrates and products
									for (DefaultWeightedEdge e : clone.edgesOf(newReaction)) {
										if (!e.equals(newAddedEdge1) && !e.equals(newAddedEdge2))
											clone.setEdgeWeight(e, clone.getEdgeWeight(e)*solve[2]);
									}
								}
								// get the new reaction equation
								String newEquation = getReactionEquation(clone, newReaction);
								
								// this line was used for matching matrixSubstitutions and equationSubstitutions files
								// print <reaction> <old compound1> <old compound2> <new compound1> <new compound2> and first 4 triplets: [i1_old,j]=s1_old, [i2_old,j]=s2_old, [i1_new,j]=s1_new, [i2_new,j]=s2_new
//								doublesWriter.write(reaction.getName()+"\tD="+deltaGrString+"\td="+deltaGdiffString+"\t"+compound1.getName()+Utilities.DELIMITER_COMPOUND_COMPARTMENT+compound1.getCompartment()+"\t"+compound2.getName()+Utilities.DELIMITER_COMPOUND_COMPARTMENT+compound2.getCompartment()
//										+"\t"+substitute1.getName()+Utilities.DELIMITER_COMPOUND_COMPARTMENT+substitute1.getCompartment()+"\t"+substitute2.getName()+Utilities.DELIMITER_COMPOUND_COMPARTMENT+substitute2.getCompartment()+"\t");
								
								// print <reaction> <old_equation> <deltaGr> <new_equation> <diff> 
								doublesWriter.write(reaction.getName()+"\t"+equation+"\t"+deltaGrString+"\t"+newEquation+"\t"+deltaGdiffString+"\n");
							}
						}
					}
				}
			}
		}
		
		singlesWriter.close();
		if (doubles)
			doublesWriter.close();
	}
	
	/**
	 * Calculates the difference in deltaG of the reaction after substituting compound
	 * by substitute on the given side, without modifying the network.
	 * For reversible reactions, the difference is calculated for the direction of the given reaction,
	 * as the full deltaGr is always 0.
	 * 
	 * @param reaction
	 * @param side
	 * @param compound
	 * @param substitute
	 * @return Difference in deltaG.
	 */
	public Double getDeltaGDifference(Vertex reaction, int side, Vertex compound, Vertex substitute, int[] solve) {
		final int LEFT = 0;
		Double diff = null;
		Double deltaGr = null;
		
		// calculate the difference in deltaGf
		Double substituteDeltaGf = substitute.getDeltaGf();
		Double compoundDeltaGf = compound.getDeltaGf();
		
		if (substituteDeltaGf == null || compoundDeltaGf == null)
			return null;

		// get the quotient of the old and new weights
		double compoundWeight = (side == LEFT ? (getEdgeWeight(getEdge(compound, reaction))) : (getEdgeWeight(getEdge(reaction, compound))));
		
		if (solve[1] == 1) {
			// if there is no stoichiometry update we can calculate the difference in deltaGr from the differences in deltaGf times the coefficients 
			diff = (side == LEFT ? -solve[0]*substituteDeltaGf + compoundWeight*compoundDeltaGf : solve[0]*substituteDeltaGf - compoundWeight*compoundDeltaGf);
		} else if ((deltaGr = getDeltaGr(reaction, false)) != null){
			// the difference in deltaGr is the update factor times the old deltaGr plus the coefficients times the deltaGf 
			diff = solve[1]*deltaGr + (side == LEFT ? -solve[0]*substituteDeltaGf+solve[1]*compoundWeight*compoundDeltaGf : solve[0]*substituteDeltaGf-solve[1]*compoundWeight*compoundDeltaGf);
		}
		
		return diff;
	}
	
	/**
	 * Calculates the difference in deltaG of the reaction after substituting compound1
	 * and compound1 by substitute1 and substitute2 on the given side. For reversible reactions,
	 * the difference is calculated for the direction of the given reaction.
	 * 
	 * @param reaction
	 * @param side
	 * @param compound1
	 * @param compound2
	 * @param substitute1
	 * @param substitute2
	 * @param solve
	 * @return Difference in deltaG.
	 */
	public Double getDeltaGDifference(Vertex reaction, int side, Vertex compound1, Vertex compound2, Vertex substitute1, Vertex substitute2, int[] solve) {
		final int LEFT = 0;
		Double diff = null;
		Double deltaGr = null;
		
		// calculate the differences in deltaGf
		Double substitute1DeltaGf = substitute1.getDeltaGf();
		Double substitute2DeltaGf = substitute2.getDeltaGf();
		Double compound1DeltaGf = compound1.getDeltaGf();
		Double compound2DeltaGf = compound2.getDeltaGf();
		
		if (substitute1DeltaGf == null || substitute2DeltaGf == null
				|| compound1DeltaGf == null || compound2DeltaGf == null)
			return null;

		// get the quotient of the old and new weights
		double compound1Weight = (side == LEFT ? (getEdgeWeight(getEdge(compound1, reaction))) : (getEdgeWeight(getEdge(reaction, compound1))));
		double compound2Weight = (side == LEFT ? (getEdgeWeight(getEdge(compound2, reaction))) : (getEdgeWeight(getEdge(reaction, compound2))));
		
		if (solve[2] == 1) {
			// the difference in deltaGr is the difference in deltaGf times the coefficients
			if (side == LEFT) 
				diff = -solve[0]*substitute1DeltaGf - solve[1]*substitute2DeltaGf + compound1Weight*compound1DeltaGf + compound2Weight*compound2DeltaGf;
			else
				diff = solve[0]*substitute1DeltaGf + solve[1]*substitute2DeltaGf - compound1Weight*compound1DeltaGf - compound2Weight*compound2DeltaGf;
		} else if ((deltaGr = getDeltaGr(reaction, false)) != null){
			// the difference in deltaGr is the update factor times the old deltaGr plus the coefficients times the deltaGf 
			diff = solve[2]*deltaGr;
			if (side == LEFT)
				diff += (-solve[0]*substitute1DeltaGf - solve[1]*substitute2DeltaGf + solve[2]*compound1Weight*compound1DeltaGf + solve[2]*compound2Weight*compound2DeltaGf);
			else
				diff += (solve[0]*substitute1DeltaGf + solve[1]*substitute2DeltaGf - solve[2]*compound1Weight*compound1DeltaGf - solve[2]*compound2Weight*compound2DeltaGf);
		}
		
		return diff;
	}
	
	
	/**
	 * Counts the differences in substrates and products between the given
	 * reaction and the corresponding reaction with the same name in the
	 * given graph.
	 * 
	 * Note that this method assumes both reactions have the same number of
	 * substrates and products, and compounds have the same names.
	 * 
	 * @param reaction
	 * @param graph
	 */
	private int distance(Vertex reaction, MetabolicGraph graph) {
		HashSet<Vertex> substrates = new HashSet<Vertex>(Graphs.predecessorListOf(graph, graph.getReaction(reaction.getName())));
		HashSet<Vertex> products = new HashSet<Vertex>(Graphs.successorListOf(graph, graph.getReaction(reaction.getName())));
		
		// determine the differences to the given network: number of different substrates/products
		int distance = 0;
		for (Vertex substrate : substrates) {
			Vertex newSubstrate = this.getCompound(substrate.getName(), substrate.getCompartment());
			if (!this.containsEdge(newSubstrate, reaction))
				distance++;
		}
		for (Vertex product : products) {
			Vertex newProduct = this.getCompound(product.getName(), product.getCompartment());
			if (!this.containsEdge(reaction, newProduct))
				distance++;
		}
		
		return distance;
	}
	
	/**
	 * Counts the differences in substrates and products between this graph
	 * and the given graph.
	 * 
	 * Note that this method assumes all corresponding reactions have the same number of
	 * substrates and products, and compounds have the same names.
	 * 
	 * @param graph
	 */
	public int distanceTo(MetabolicGraph graph) {
		int distance = 0;
		
		for (Vertex reaction : getReactions())
			distance += distance(reaction, graph);
			
		return distance;
	}
	
	/**
	 * Determines whether the removal of edges changes the size of the strongly connected component.
	 * 
	 * @param edge1
	 * @param edge2
	 * @return
	 */
	protected boolean isStrongComponentEssential(List<Set<Vertex>> components, DefaultWeightedEdge edge1, DefaultWeightedEdge edge2) {
		boolean debug = false;
		Vertex compound1 = (getEdgeSource(edge1).getType()==Vertex.COMPOUND ? getEdgeSource(edge1) : getEdgeTarget(edge1));
		Vertex compound2 = null;
		if (edge2 != null)
			compound2 = (getEdgeSource(edge2).getType()==Vertex.COMPOUND ? getEdgeSource(edge2) : getEdgeTarget(edge2));
		
		// determine the size of the compound' strongly connected component 
		int size1 = 0, size2 = 0;
		for (Set<Vertex> component : components) {
			if (component.contains(compound1))
				size1 = component.size();
			if (component.contains(compound2))
				size2 = component.size();
			if (size1 > 0 && (edge2 == null || size2 > 0))
				break;
		}
		// remove edges
		removeEdge(edge1);
		if (edge2 != null)
			removeEdge(edge2);
		// compare the resulting component size
		int newSize1 = 0, newSize2 = 0;
		StrongConnectivityInspector<Vertex, DefaultWeightedEdge> connectivity = new StrongConnectivityInspector<Vertex, DefaultWeightedEdge>(this);
		for (Set<Vertex> component : connectivity.stronglyConnectedSets()) {
			if (component.contains(compound1))
				newSize1 = component.size();
			if (component.contains(compound2))
				newSize2 = component.size();
			if (newSize1 > 0 && (edge2 == null || newSize2 > 0))
				break;
		}
		// restore the removed edges
		addEdge(getEdgeSource(edge1), getEdgeTarget(edge1), edge1);
		if (edge2 != null)
			addEdge(getEdgeSource(edge2), getEdgeTarget(edge2), edge2);
		
		if (debug) {
			System.out.println("old1: "+size1+", new1: "+newSize1);
			System.out.println("old2: "+size2+", new2: "+newSize2);
		}
		
		return (newSize1 != size1 || newSize2 != size2);
	}
	
	/**
	 * Given a new substitute mass vector, original coefficient and mass, calculates the new
	 * stoichiometric coefficient x such that x*substituteMass has the same mass as
	 * coefficient*originalMass. If no such integer exists, then the least integer multiple of x
	 * and the integer factor by which x was multiplied are returned (up to a maximum factor,
	 * otherwise, null is returned).
	 * The factor can then be used to multiple the stoichiometric coefficients of other
	 * substrates/products.
	 * 
	 * @param substituteMass
	 * @param coefficient
	 * @param originalMass
	 * @return The new stoichiometric coefficient for the substitute mass, if this is an integer,
	 * otherwise two integers are returned: the least integer multiple of x, and the integer
	 * factor by which x was multiplied.
	 */
	protected int[] solveStoichiometry(int[] substituteMass, int coefficient, int[] originalMass) {
		boolean debug = false;
		
		if (substituteMass.length != Utilities.ELEMENTS.length || originalMass.length != Utilities.ELEMENTS.length)
			throw new IllegalArgumentException("Mass vector has invalid size.");
		
		MathContext precision = MathContext.DECIMAL64;
		BigDecimal fraction = null;
		
		// calculate the new stoichiometric coefficient
		for (int i=0; i<Utilities.ELEMENTS.length; i++) {
			if (substituteMass[i] == 0 && originalMass[i] == 0)
				continue;
			if (substituteMass[i] == 0 ^ originalMass[i] == 0)
				throw new IllegalArgumentException("Masses are not linearly dependent.");
			// fraction = coefficient / (substituteMass[i] / originalMass[i])
			fraction = new BigDecimal(coefficient).divide(new BigDecimal(substituteMass[i]).divide(new BigDecimal(originalMass[i]), precision), precision);
			break;
		}
		
		// check if the fraction is close to an integer
		float fractionF = fraction.floatValue();
		if (fractionF == Math.round(fractionF))
			return new int[]{Math.round(fractionF),1};
		else {
			// no integer solution: determine the least integer multiple
			int i=1;
			BigDecimal temp = fraction;
			do {
				temp = fraction.multiply(new BigDecimal(++i));
			} while (i<Utilities.MAX_STOICHIOMETRY_FACTOR && temp.floatValue() != Math.round(temp.floatValue()));
			
			int newCoefficient = Math.round(temp.floatValue());
			if (temp.floatValue() == newCoefficient) {
				// return the new coefficient and the factor by which it was multiplied
				if (debug)
					System.out.println("Found integer multiple: "+fraction.floatValue()+"*"+i+"="+temp.floatValue());
				return new int[]{newCoefficient,i};
			} else {
				if (debug)
					System.out.println("No integer multiple up to a factor of "+i+" for "+fraction.floatValue());
				return null;
			}
		}
	}
	
	/**
	 * Solves the linear equation system a1*x + a2*y = b, where b = coeff1*b1 + coeff2*b2,
	 * using backsubstitution and simple pivoting.
	 *
	 * Given substitute mass vectors a1 and a2, the original coefficients coeff1 and coeff2, and
	 * the original mass vectors b1 and b2, the new stoichiometric coefficients x and y for a1
	 * and a2 are calculated such that a1*x + a2*y = coeff1*b1 + coeff2*b2. If a non-integer
	 * solution exists, then 3 integers are returned: (1,2) the least integer multiple of the solution,
	 * and (3) the integer factor by which the solution was multiplied. 
	 * If the matrix [a1 a2] is not regular, i.e., all of its rows are pairwise linearly dependent,
	 * then an exhaustive search determines a solution.
	 * 
	 * NOTE: the use of BigDecimal avoids precision problems for large scalars (RXN0-2001 in EcoCyc13.5).
	 * 
	 * @return the coefficients x and y, or null, if there is no solution.
	 */
	protected int[] solveStoichiometry(int[] a1, int[] a2, int coeff1, int coeff2, int[] b1, int[] b2, boolean timing) {
		boolean debug = false;
		boolean regular = false;
		int x = 0, y = 0, factor = 1;
		int pivotRow = -1;
		double almostZero = 0.0001;
		double pivot_a = -1, pivot_b = -1;
		double[] solution = {0,0};
		
		if (a1.length != Utilities.ELEMENTS.length || a2.length != Utilities.ELEMENTS.length || b1.length != Utilities.ELEMENTS.length || b2.length != Utilities.ELEMENTS.length)
			throw new IllegalArgumentException("Mass vector has invalid size.");
		
		// create matrix a and right-hand side vector b
		double[][] a = new double[Utilities.ELEMENTS.length][2];
		double[] b = new double[Utilities.ELEMENTS.length];
		if (debug)
			System.out.println("a[i,0]\ta[i,1]\tb[i]");
		for (int i=0; i<a.length; i++) {
			a[i][0] = a1[i];
			a[i][1] = a2[i];
			b[i] = (coeff1 * b1[i] + coeff2 * b2[i]);
			if (debug)
				System.out.println(a[i][0]+"\t"+a[i][1]+"\t"+b[i]);
		}
		
		// iterate over the rows of the matrix until a local solution can be substituted
		// this loop takes most of the time in most calls
		for (int i=0; i<Utilities.ELEMENTS.length; i++) {

			// skip zero rows
			if (a1[i] == 0 && a2[i] == 0)
				continue;
			
			// x was found: backsubstitute y
			if (solution[0] > almostZero && a2[i] > 0)
				solution[1] = (b[i] - solution[0] * a[i][0]) / a[i][1];
			// y was found: backsubstitute x
			else if (solution[1] > almostZero && a1[i] > 0)
				solution[0] = (b[i] - solution[1] * a[i][1]) / a[i][0];
			
			// one column is zero: backsubstitute one solution
			else if (a2[i] == 0) {
				solution[0] = b[i] / a[i][0];
				if (pivotRow > -1)
					solution[1] = (b[pivotRow] - solution[0] * a[pivotRow][0]) / a[pivotRow][1];
			} else if (a1[i] == 0) {
				solution[1] = b[i] / a[i][1];
				if (pivotRow > -1)
					solution[0] = (b[pivotRow] - solution[1] * a[pivotRow][1]) / a[pivotRow][0];
					
			} else if (pivotRow == -1) {
				// no column is zero and no variable was solved: normalize row i by a[i][0]
				pivot_a = a[i][1] / a[i][0];
				pivot_b = b[i] / a[i][0];
				pivotRow = i;
				if (debug) {
					System.out.println("pivots [i="+i+"]: "+a[i][1]+"/"+a[i][0]+" = "+pivot_a+", "+b[i]+"/"+a[i][0]+" = "+pivot_b);
					System.out.println("normalized row "+i+" (unmodified a): {1, "+pivot_a+"}");
				}
			} else {
				// subtract a multiple of the pivot row from this row to generate zero element
				pivot_a = a[i][1] - a[i][0] * (a[pivotRow][1] / a[pivotRow][0]);
				pivot_b = b[i] - a[i][0] * (b[pivotRow] / a[pivotRow][0]);
				if (debug)
					System.out.println("pivots [i="+i+"]: "+pivot_a+", "+pivot_b);
				// backsubstitute the solution
				if (pivot_a < almostZero && pivot_a > -almostZero) {
					regular = false;
					if (debug)
						System.out.println("Rows "+pivotRow+" and "+i+" are linearly dependent.");
				} else {
					solution[1] = pivot_b / pivot_a;
					solution[0] = (b[pivotRow] - solution[1] * a[pivotRow][1]) / a[pivotRow][0];
				}
			}
			
			if (solution[0] > almostZero && solution[1] > almostZero) {
				regular = true;
				break;
			} else if (solution[0] < -almostZero || solution[1] < -almostZero)
				return null;
		}
		
		if (debug)
			System.out.println("Preliminary solution: "+solution[0]+", "+solution[1]);
		
		// if the solution is non-integer, determine the least integer multiple
		double s0 = solution[0], s1 = solution[1];
		while (factor<Utilities.MAX_STOICHIOMETRY_FACTOR && (Math.abs(s0-Math.round(s0)) > almostZero || Math.abs(s1-Math.round(s1)) > almostZero)) {
			factor++;
			s0 = solution[0] * factor;
			s1 = solution[1] * factor;
		}
		
		// round the solution to the nearest integer
		x = (int)Math.round(s0);
		y = (int)Math.round(s1);
		if (Math.abs(x-Math.round(s0)) > almostZero || Math.abs(y-Math.round(s1)) > almostZero) {
			if (debug)
				System.out.println("No integer multiple up to a factor of "+factor+" for "+solution[0]+" and "+solution[1]);
			return null;
		}
		
		if (debug && (s0 != solution[0] || s1 != solution[1]))
			System.out.println("Found integer multiples: "+solution[0]+"*"+factor+"="+s0+", "+solution[1]+"*"+factor+"="+s1);
		
		// update b
		for (int i=0; i<Utilities.ELEMENTS.length; i++)
			b[i] *= factor;

		// irregular matrix: find the solution by exhaustive search
		if (!regular) {
			
			// take the first row without zeros
			int row = 0;
			while (row < Utilities.ELEMENTS.length-1 && (a[row][0] == 0 || a[row][1] == 0))
				row++;
			if (a[row][0] == 0 || a[row][1] == 0)
				throw new RuntimeException("Zero mass vector.");
			// calculate the maximum possible x
			int xmax = (int)((b[row] - a[row][1]) / a[row][0]) + 1;
			if (debug)
				System.out.println("Maximum x="+xmax);
			
			// check all x in [1,xmax] for a solution
			for (x = 1; x <= xmax; x++) {
				y = (int)((b[row] - x * a[row][0]) / a[row][1]);
				check:
				if (y > 0) {
					// check if the solution is a global solution
					for (int k=0; k<Utilities.ELEMENTS.length; k++)
						if (x * a[k][0] + y * a[k][1] != b[k])
							break check;
					if (debug)
						System.out.println("Found solution by exhaustive search: x="+x+", y="+y);
					return new int[]{x,y,factor};
				}
			}
		}
		
		if (x < 1 || y < 1)
			return null;
		
		if (debug)
			System.out.println("Local solution: "+x+","+y);
		
		// check if the approximated solution is a global solution, otherwise no solution is found.
		try {
			for (int j=0; j<Utilities.ELEMENTS.length; j++) {
				if ((x * a[j][0] + y * a[j][1]) != b[j]) {
					if (debug)
						System.out.println("Solution does not satisfy row "+j+": "+x+"*"+a[j][0]+" + "+y+"*"+a[j][1]+" != "+b[j]);
					return null;
				}
			}
		} catch (ArithmeticException e) {
			// TODO determine the required integer factor
			return null;
		}
		
		if (debug)
			System.out.println("Partial approximate solution is a global solution: x="+x+", y="+y);
		
		return new int[]{x,y,factor};
	}
	
	protected int[] solveStoichiometry_big(int[] a1, int[] a2, int coeff1, int coeff2, int[] b1, int[] b2) {
		boolean debug = false, debug2 = false;
		boolean regular = false;
		int x = 0, y = 0, factor = 1;
		int pivotRow = -1;
		long time = 0;
		float almostZero = 0.000001f;
		BigDecimal pivot_a = new BigDecimal("-1"), pivot_b = new BigDecimal("-1");
		BigDecimal[] solution = {new BigDecimal("0"), new BigDecimal("0")};
		MathContext precision = MathContext.DECIMAL64; // DECIMAL32 is insufficient
		
		if (a1.length != Utilities.ELEMENTS.length || a2.length != Utilities.ELEMENTS.length || b1.length != Utilities.ELEMENTS.length || b2.length != Utilities.ELEMENTS.length)
			throw new IllegalArgumentException("Mass vector has invalid size.");
		
		if (debug2)
			time = System.nanoTime();
		
		// create matrix a and right-hand side vector b
		BigDecimal[][] a = new BigDecimal[Utilities.ELEMENTS.length][2];
		BigDecimal[] b = new BigDecimal[Utilities.ELEMENTS.length];
		if (debug)
			System.out.println("a[i,0]\ta[i,1]\tb[i]");
		for (int i=0; i<a.length; i++) {
			a[i][0] = new BigDecimal(a1[i]);
			a[i][1] = new BigDecimal(a2[i]);
			b[i] = new BigDecimal(coeff1 * b1[i] + coeff2 * b2[i]);
			if (debug)
				System.out.println(a[i][0].intValueExact()+"\t"+a[i][1].intValueExact()+"\t"+b[i].intValueExact());
		}
		
		if (debug2) {
			System.out.println("A: "+(System.nanoTime()-time));
			time = System.nanoTime();
		}
		
		// iterate over the rows of the matrix until a local solution can be substituted
		// this loop takes most of the time in most calls
		for (int i=0; i<Utilities.ELEMENTS.length; i++) {

			// skip zero rows
			if (a1[i] == 0 && a2[i] == 0)
				continue;
			
			// x was found: backsubstitute y
			if (solution[0].floatValue() > almostZero && a2[i] > 0)
				// solution[1] = (b[i] - solution[0] * a[i][0]) / a[i][1];
				solution[1] = (b[i].subtract(solution[0].multiply(a[i][0]))).divide(a[i][1], precision);
			// y was found: backsubstitute x
			else if (solution[1].floatValue() > almostZero && a1[i] > 0)
				// solution[0] = (b[i] - solution[1] * a[i][1]) / a[i][0];
				solution[0] = (b[i].subtract(solution[1].multiply(a[i][1]))).divide(a[i][0], precision);
			
			// one column is zero: backsubstitute one solution
			else if (a2[i] == 0) {
				solution[0] = b[i].divide(a[i][0], precision);
				if (pivotRow > -1)
					// solution[1] = (b[pivotRow] - solution[0] * a[pivotRow][0]) / a[pivotRow][1];
					solution[1] = (b[pivotRow].subtract(solution[0].multiply(a[pivotRow][0]))).divide(a[pivotRow][1], precision);
			} else if (a1[i] == 0) {
				solution[1] = b[i].divide(a[i][1], precision);
				if (pivotRow > -1)
					// solution[0] = (b[pivotRow] - solution[1] * a[pivotRow][1]) / a[pivotRow][0];
					solution[0] = (b[pivotRow].subtract(solution[1].multiply(a[pivotRow][1]))).divide(a[pivotRow][0], precision);
					
			} else if (pivotRow == -1) {
				// no column is zero and no variable was solved: normalize row i by a[i][0]
				pivot_a = a[i][1].divide(a[i][0], precision);
				pivot_b = b[i].divide(a[i][0], precision);
				pivotRow = i;
				if (debug) {
					System.out.println("pivots [i="+i+"]: "+a[i][1]+"/"+a[i][0]+" = "+pivot_a+", "+b[i]+"/"+a[i][0]+" = "+pivot_b);
					System.out.println("normalized row "+i+" (unmodified a): {1, "+pivot_a+"}");
				}
			} else {
				// subtract a multiple of the pivot row from this row to generate zero element
//				pivot_a = a[i][1] - a[i][0] * (a[pivotRow][1] / a[pivotRow][0]);
				pivot_a = a[i][1].subtract(a[i][0].multiply(a[pivotRow][1]).divide(a[pivotRow][0], precision));
//				pivot_b = b[i] - a[i][0] * (b[pivotRow] / a[pivotRow][0]);
				pivot_b = b[i].subtract(a[i][0].multiply(b[pivotRow]).divide(a[pivotRow][0], precision));
				if (debug)
					System.out.println("pivots [i="+i+"]: "+pivot_a+", "+pivot_b);
				// backsubstitute the solution
				if (pivot_a.floatValue() < almostZero && pivot_a.floatValue() > -almostZero) {
					regular = false;
					if (debug)
						System.out.println("Rows "+pivotRow+" and "+i+" are linearly dependent.");
				} else {
					solution[1] = pivot_b.divide(pivot_a, precision);
					// solution[0] = (b[pivotRow] - solution[1] * a[pivotRow][1]) / a[pivotRow][0];
					solution[0] = (b[pivotRow].subtract(solution[1].multiply(a[pivotRow][1]))).divide(a[pivotRow][0], precision);
				}
			}
			
			if (solution[0].floatValue() > almostZero && solution[1].floatValue() > almostZero) {
				regular = true;
				break;
			} else if (solution[0].floatValue() < -almostZero || solution[1].floatValue() < -almostZero)
				return null;
		}
		
		if (debug2) {
			System.out.println("B: "+(System.nanoTime()-time));
			time = System.nanoTime();
		}
		
		if (debug)
			System.out.println("Preliminary solution: "+solution[0].floatValue()+", "+solution[1].floatValue());
		
		// if the solution is non-integer, determine the least integer multiple
		
		BigDecimal s0 = solution[0], s1 = solution[1];
		while (factor<1000 && (s0.floatValue() != Math.round(s0.floatValue()) || s1.floatValue() != Math.round(s1.floatValue()))) {
			factor++;
			s0 = solution[0].multiply(new BigDecimal(factor));
			s1 = solution[1].multiply(new BigDecimal(factor));
		}
		
		if (debug2) {
			System.out.println("C: "+(System.nanoTime()-time));
			time = System.nanoTime();
		}
		
		// round the solution to the nearest integer
		x = Math.round(s0.floatValue());
		y = Math.round(s1.floatValue());
		if (x != s0.floatValue() || y != s1.floatValue()) {
			if (debug)
				System.out.println("No integer multiple up to a factor of "+factor+" for "+solution[0].floatValue()+" and "+solution[1].floatValue());
			return null;
		}
		
		if (debug && (!s0.equals(solution[0]) || !s1.equals(solution[1])))
			System.out.println("Found integer multiples: "+solution[0].floatValue()+"*"+factor+"="+s0.floatValue()+", "+solution[1].floatValue()+"*"+factor+"="+s1.floatValue());
		
		// update b
		for (int i=0; i<Utilities.ELEMENTS.length; i++)
			b[i] = b[i].multiply(new BigDecimal(factor));
		
		if (debug2) {
			System.out.println("D: "+(System.nanoTime()-time));
			time = System.nanoTime();
		}

		// irregular matrix: find the solution by exhaustive search
		if (!regular) {
			int row = 0;
			while (row < Utilities.ELEMENTS.length-1 && (a[row][0].intValueExact() == 0 || a[row][1].intValueExact() == 0))
				row++;
			if (a[row][0].equals(BigDecimal.ZERO) || a[row][1].equals(BigDecimal.ZERO))
				throw new RuntimeException("Zero mass vector.");
			int xmax = (b[row].subtract(a[row][1])).divide(a[row][0], precision).intValue() + 1;
			int ymax = (b[row].subtract(a[row][0])).divide(a[row][1], precision).intValue() + 1;
			if (debug)
				System.out.println("Maximum x="+xmax+", maximum y="+ymax);
			// mathematically sound
			for (x = 1; x <= xmax; x++) {
				for (y = 1; y <= ymax; y++) {
					check:
					if (x * a[row][0].intValueExact() + y * a[row][1].intValueExact() == b[row].intValueExact()) {
						// check if the solution is a global solution
						for (int k=0; k<Utilities.ELEMENTS.length; k++)
							if (x * a[k][0].intValueExact() + y * a[k][1].intValueExact() != b[k].intValueExact())
								break check;
						if (debug)
							System.out.println("Found solution by exhaustive search: x="+x+", y="+y);
						return new int[]{x,y,factor};
					}
				}
			}
		}
		
		if (debug2) {
			System.out.println("E: "+(System.nanoTime()-time));
			time = System.nanoTime();
		}
		
		if (x < 1 || y < 1)
			return null;
		
		if (debug)
			System.out.println("Local solution: "+x+","+y);
		
		// check if the approximated solution is a global solution, otherwise no solution is found.
		try {
			for (int j=0; j<Utilities.ELEMENTS.length; j++) {
				if ((x * a[j][0].intValueExact() + y * a[j][1].intValueExact()) != b[j].intValueExact()) {
					if (debug)
						System.out.println("Solution does not satisfy row "+j+": "+x+"*"+a[j][0].intValueExact()+" + "+y+"*"+a[j][1].intValueExact()+" != "+b[j].intValueExact());
					return null;
				}
			}
		} catch (ArithmeticException e) {
			// TODO determine the required integer factor
			return null;
		}
		
		if (debug2) {
			System.out.println("F: "+(System.nanoTime()-time));
			time = System.nanoTime();
		}
		
		if (debug)
			System.out.println("Partial approximate solution is a global solution: x="+x+", y="+y);
		
		return new int[]{x,y,factor};
	}
	
	/**
	 * Returns the first found duplicate reaction. Two reactions are duplicate, if either they have
	 * identical substrates and products with equal stoichiometric cofficients, or if one of them is
	 * reversible and the substrates of one reaction equal the products of the other (and vice versa).
	 * 
	 * If no such duplicate exists, null is returned. For reactions with in- and out-degree zero
	 * null is returned, even though such duplicates may exist. 
	 * 
	 * @return The first found duplicate reaction, if it exists, null otherwise.
	 */
	public Vertex isDuplicate(Vertex reaction) {
		boolean debug = false;
		
		if (reaction.getType() != Vertex.REACTION)
			throw new IllegalArgumentException("Cannot invoke method with a Vertex not of type Vertex.REACTION.");
		if (reaction.isReversed())
			throw new IllegalArgumentException("Cannot invoke method with a reversed reaction.");
		
		int inDegree = inDegreeOf(reaction);
		int outDegree = outDegreeOf(reaction);
		if (inDegree == 0 && outDegree == 0)
			return null;
		boolean left = (inDegree > 0);
		
		if (debug)
			System.out.println("isDuplicate("+reaction.getName()+(reaction.reversedReaction() != null?"(reversible)":"")+")");
		
		// hash set conversion ensures the order of compounds is not considered
		HashSet<Vertex> substrates = new HashSet<Vertex>(Graphs.predecessorListOf(this, reaction));
		HashSet<Vertex> products = new HashSet<Vertex>(Graphs.successorListOf(this, reaction));
		
		// compare the reaction to all reactions with an identical adjacent compound
		Vertex neighbour = (left ? substrates.iterator().next() : products.iterator().next());
		// collect all neighbouring reactions (both sides of the adjacent compound)
		List<Vertex> neighbourReactions = Graphs.successorListOf(this, neighbour);
		neighbourReactions.addAll(Graphs.predecessorListOf(this, neighbour));
		
		for (Vertex neighbourReaction : neighbourReactions) {
			boolean duplicate = false;
			// skip reversed reactions and the reaction itself
			if (neighbourReaction.isReversed() || neighbourReaction.equals(reaction))
				continue;
			// if this reaction or the neighbour is reversible, then check both directions
			boolean reversible = (reaction.reversedReaction() != null || neighbourReaction.reversedReaction() != null);
			boolean reversed = false;
			if (debug)
				System.out.println("checking neighbour through "+neighbour.getName()+": "+neighbourReaction.getName()+(reaction.reversedReaction()!=null?"(reversible)":"")+"");
			
			// check for equal substrates and products, or substrates and products switched (reversed)
			if (substrates.equals(new HashSet<Vertex>(Graphs.predecessorListOf(this, neighbourReaction))) && products.equals(new HashSet<Vertex>(Graphs.successorListOf(this, neighbourReaction))))
				duplicate = true;
			else if (reversible && (substrates.equals(new HashSet<Vertex>(Graphs.successorListOf(this, neighbourReaction))) && products.equals(new HashSet<Vertex>(Graphs.predecessorListOf(this, neighbourReaction))))) {
				duplicate = true;
				reversed = true;
			} else if (debug) {
				System.out.println("reject: unequal substrates/products.");
			}
			
			// check the stoichiometric cofficients for equality
			if (duplicate) {
				for (Vertex substrate : substrates) {
					double weight1 = getEdgeWeight(getEdge(substrate, reaction));
					double weight2 = (reversed ? getEdgeWeight(getEdge(neighbourReaction, substrate)) : getEdgeWeight(getEdge(substrate, neighbourReaction)));
					if (weight1 != weight2) {
						duplicate = false;
						if (debug)
							System.out.println("unequal cofficients: "+weight1+" != "+weight2);
						break;
					}
				}
				if (duplicate) {
					for (Vertex product : products) {
						double weight1 = getEdgeWeight(getEdge(reaction, product));
						double weight2 = (reversed ? getEdgeWeight(getEdge(product, neighbourReaction)) : getEdgeWeight(getEdge(neighbourReaction, product)));
						if (weight1 != weight2) {
							duplicate = false;
							if (debug)
								System.out.println("unequal cofficients: "+weight1+" != "+weight2);
							break;
						}
					}
				}
			}
			
			if (duplicate) {
				if (debug)
					System.out.println((reversed?"reversed ":"")+"duplicate found: "+neighbourReaction.getName());
				return neighbourReaction;
			}
		}
		
		return null;
	}
	
	/**
	 * <p>
	 * Performs switch-randomization on the graph. Two (non-reversed) edges of the same type (substrate
	 * or product) are drawn at random and switched, i.e., the corresponding sources and targets of the
	 * edges are exchanged. The reaction degrees are preserved, because only vertices of the same type
	 * (substrate or product) are exchanged. If strict==true, then reversible reactions are never switched
	 * with irreversible reactions, such that the in- and out-degrees of compounds are preserved. If
	 * strict==false, then reversible reactions may be switched with irreversible reactions, in which
	 * case the in- and out-degrees of switched compounds increase respectively decrease by 1. In any case,
	 * the total number of chemical reactions any compound takes part in (reversible+irreversible) is
	 * preserved. 
	 * 
	 * <p>
	 * In case the drawn edges share a common source or target, the graph is not actually modified.
	 * 
	 * <p>
	 * The number of perturbations is given by the number of distinct substrate edge pairs plus the number of
	 * distinct product edge pairs, i.e., s*(s-1)+p*(p-1), where s is the number of substrate edges and p the
	 * number of product edges. 
	 * 
	 * <p>
	 * Note that reversed reactions are not switched explicitly, as they are synchronized implicitly with
	 * every modification (see {@link MetabolicGraph#addEdge(Vertex,Vertex)}).
	 * 
	 * @param strict
	 */
	public void switchRandomize(boolean strict) {
		boolean debug = false;
		int iterations = 0, numSubstrateEdges = 0, numProductEdges = 0;
		final int MAXTRIES = 10000;
		HashMap<String,Integer> compartmentSubstrateEdges = new HashMap<String,Integer>();
		HashMap<String,Integer> compartmentProductEdges = new HashMap<String,Integer>();
		HashMap<String, Integer> inDegrees = null, outDegrees = null;
		
		Random random = new Random();
		
		if (debug) {
			// store the original degree sequence
			inDegrees = new HashMap<String, Integer>();
			outDegrees = new HashMap<String, Integer>();
			for (Vertex compound : getCompounds()) {
				inDegrees.put(compound.getName(), inDegreeOf(compound));
				outDegrees.put(compound.getName(), outDegreeOf(compound));
			}
		}
		
		
		// collect the substrate and product edges of non-reversed reactions
		int numEdges = reversible ? edgeSet().size()/2 : edgeSet().size();
		ArrayList<DefaultWeightedEdge> substrateEdges = new ArrayList<DefaultWeightedEdge>(numEdges);
		ArrayList<DefaultWeightedEdge> productEdges = new ArrayList<DefaultWeightedEdge>(numEdges);
		for (Iterator<DefaultWeightedEdge> edgeIterator = edgeSet().iterator(); edgeIterator.hasNext();) {
			DefaultWeightedEdge edge = edgeIterator.next();
			// skip edges of reversed reactions, and transport/import/export reactions if this.compartments==true
			if (getEdgeSource(edge).getType() == Vertex.COMPOUND) {
				Vertex reaction = getEdgeTarget(edge);
				if (!reaction.isReversed() && (!this.compartments || (getCompartments(reaction).keySet().size() <= 1 && inDegreeOf(reaction) != 0 && outDegreeOf(reaction) != 0))) {
					substrateEdges.add(edge);
					if (this.compartments) {
						// count the number of substrate edges for every compartment
						Integer substrates = compartmentSubstrateEdges.get(getEdgeSource(edge).getCompartment());
						compartmentSubstrateEdges.put(getEdgeSource(edge).getCompartment(), substrates!=null ? (substrates.intValue()+1) : 1);
					}
				}
			} else {
				Vertex reaction = getEdgeSource(edge);
				if (!reaction.isReversed() && (!this.compartments || (getCompartments(reaction).keySet().size() <= 1 && inDegreeOf(reaction) != 0 && outDegreeOf(reaction) != 0))) {
					productEdges.add(edge);
					if (this.compartments) {
						// count the number of product edges for every compartment
						Integer products = compartmentProductEdges.get(getEdgeTarget(edge).getCompartment());
						compartmentProductEdges.put(getEdgeTarget(edge).getCompartment(), products!=null ? (products.intValue()+1) : 1);
					}
				}
			}
		}
		
		numSubstrateEdges = substrateEdges.size();
		numProductEdges = productEdges.size();
		
		if (this.compartments) {
			// determine the number of iterations = number of edge pairs of equal type and in the same compartment
			for (Integer substrates : compartmentSubstrateEdges.values())
				iterations += (substrates.intValue()*(substrates.intValue()-1)/2);
			for (Integer products : compartmentProductEdges.values())
				iterations += (products.intValue()*(products.intValue()-1)/2);
		} else {
			// determine the number of iterations = number of edge pairs of equal type
			iterations = numSubstrateEdges*(numSubstrateEdges-1)/2 + numProductEdges*(numProductEdges-1)/2;
		}
		
		if (debug)
			System.out.println("Number of iterations: "+iterations);
		
		for (int i=0; i<iterations; i++) {
			int edgeIndex1, edgeIndex2;
			DefaultWeightedEdge edge1, edge2;
			
			// choose substrates or products 
			boolean substrate = random.nextInt(numSubstrateEdges+numProductEdges) < numSubstrateEdges;
			short timeout = 0;
			// draw random edges: skip equal edges, and edges from different compartments if this.compartments==true
			if (substrate){
				// draw two different substrate edges
				edgeIndex1 = random.nextInt(numSubstrateEdges);
				edge1 = substrateEdges.get(edgeIndex1);
				boolean reversible = (getEdgeTarget(edge1).reversedReaction() != null);
				do {
					edgeIndex2 = random.nextInt(numSubstrateEdges);
					edge2 = substrateEdges.get(edgeIndex2);
					timeout++;
					if (timeout > 10000)
						throw new RuntimeException("Infinte loop: no randomizable edges.");
				} while (edge1.equals(edge2) || (strict && reversible != (getEdgeTarget(edge2).reversedReaction() != null)) || (this.compartments && (!getEdgeSource(edge1).getCompartment().equals(getEdgeSource(edge2).getCompartment()))));
			} else {
				// draw two different product edges
				edgeIndex1 = random.nextInt(numProductEdges);
				edge1 = productEdges.get(edgeIndex1);
				boolean reversible = (getEdgeSource(edge1).reversedReaction() != null);
				do {
					edgeIndex2 = random.nextInt(numProductEdges);
					edge2 = productEdges.get(edgeIndex2);
					timeout++;
				} while (timeout < MAXTRIES && (edge1.equals(edge2) || (strict && reversible != (getEdgeSource(edge2).reversedReaction() != null)) || (this.compartments && (!getEdgeTarget(edge1).getCompartment().equals(getEdgeTarget(edge2).getCompartment())))));
				
				if (timeout == MAXTRIES) {
					// no randomizable edges were found, skip this edge
					Vertex from = getEdgeSource(edge1);
					Vertex to = getEdgeTarget(edge1);
					boolean isSubstrate = from.getType() == Vertex.COMPOUND;
					String compartment = (hasCompartments() ? (isSubstrate ? from.getCompartment() : to.getCompartment()) : "");
					String rev = (isSubstrate ? (to.isReversed() ? "$rev" : "") : (from.isReversed() ? "$rev" : ""));
					System.out.println(from.getName()+(isSubstrate ? Utilities.DELIMITER_COMPOUND_COMPARTMENT+compartment : rev)+"-->"+to.getName()+(isSubstrate ? rev : Utilities.DELIMITER_COMPOUND_COMPARTMENT+compartment)+" is not randomizable.");
					continue;
				}
			}
			
			// retrieve source and target vertices
			Vertex source1 = getEdgeSource(edge1);
			Vertex source2 = getEdgeSource(edge2);
			Vertex target1 = getEdgeTarget(edge1);
			Vertex target2 = getEdgeTarget(edge2);
			
			if (debug) {
				System.out.println("OLD: "+ source1.getName()+(source1.getType()==Vertex.COMPOUND?Utilities.DELIMITER_COMPOUND_COMPARTMENT+source1.getCompartment():"") + " ---> " + target1.getName()+(target1.getType()==Vertex.COMPOUND?Utilities.DELIMITER_COMPOUND_COMPARTMENT+target1.getCompartment():""));
				System.out.println("OLD: "+ source2.getName()+(source2.getType()==Vertex.COMPOUND?Utilities.DELIMITER_COMPOUND_COMPARTMENT+source2.getCompartment():"") + " ---> " + target2.getName()+(target2.getType()==Vertex.COMPOUND?Utilities.DELIMITER_COMPOUND_COMPARTMENT+target2.getCompartment():""));
			}
			
			// skip perturbation if any of the edges about to be created already exists
			// (this would reduce the number of edges)
			if (getEdge(source1, target2) == null && getEdge(source2, target1) == null) {
				double weight1 = getEdgeWeight(edge1);
				double weight2 = getEdgeWeight(edge2);
				
				// remove the old edges
				removeEdge(edge1);
				removeEdge(edge2);
				
				// switch sources and targets, update the edge array and set the previous weights
				if (substrate) {
					substrateEdges.set(edgeIndex1, addEdge(source1, target2));
					substrateEdges.set(edgeIndex2, addEdge(source2, target1));
					setEdgeWeight(substrateEdges.get(edgeIndex1), weight1);
					setEdgeWeight(substrateEdges.get(edgeIndex2), weight2);
				} else {
					productEdges.set(edgeIndex1, addEdge(source1, target2));
					productEdges.set(edgeIndex2, addEdge(source2, target1));
					setEdgeWeight(productEdges.get(edgeIndex1), weight1);
					setEdgeWeight(productEdges.get(edgeIndex2), weight2);
				}
				
				if (debug) {
					System.out.println("NEW: "+ source1.getName()+(source1.getType()==Vertex.COMPOUND?Utilities.DELIMITER_COMPOUND_COMPARTMENT+source1.getCompartment():"") + " ---> " + target2.getName()+(target2.getType()==Vertex.COMPOUND?Utilities.DELIMITER_COMPOUND_COMPARTMENT+target2.getCompartment():""));
					System.out.println("NEW: "+ source2.getName()+(source2.getType()==Vertex.COMPOUND?Utilities.DELIMITER_COMPOUND_COMPARTMENT+source2.getCompartment():"") + " ---> " + target1.getName()+(target1.getType()==Vertex.COMPOUND?Utilities.DELIMITER_COMPOUND_COMPARTMENT+target1.getCompartment():""));
					System.out.println();
				}
			} else if (debug) {
				System.out.println("Skipped, edge already exists: "+(getEdge(source1, target2)!=null ? source1.getName()+" ---> "+target2.getName()+"; " : "") + (getEdge(source2, target1)!=null ? source2.getName()+" ---> "+target1.getName()+"; " : ""));
			}
		}
		
		if (debug) {
			// compare with the original degree sequence
//			boolean valid = true;
			for (Vertex compound : getCompounds()) {
				if (inDegreeOf(compound) != inDegrees.get(compound.getName())) {
					System.out.println("In-degree of "+compound.getName()+" changed from "+inDegrees.get(compound.getName())+" to "+inDegreeOf(compound));
//					valid = false;
//					break;
				}
				if (outDegreeOf(compound) != outDegrees.get(compound.getName())) {
					System.out.println("Out-degree of "+compound.getName()+" changed from "+outDegrees.get(compound.getName())+" to "+outDegreeOf(compound));
//					valid = false;
//					break;
				}
			}
		}
	}
	
	/**
	 * Tests whether the graph has an edge connecting vertex1 and vertex2 in either direction.
	 * @param vertex1
	 * @param vertex2
	 * @return
	 */
	public boolean hasEdge(Vertex vertex1, Vertex vertex2) {
		return (containsEdge(vertex1, vertex2) || containsEdge(vertex2, vertex1));
	}
	
	/**********************************************
	 * Overridden methods from AbstractBaseGraph. *
	 **********************************************/
	
	/**
	 * Adds the vertex to the graph  and creates an entry in the compounds or
	 * reactions HashMap. If the graph is reversible or the vertex is of type
	 * Vertex.REACTION and has a reversed reaction, then the reversed reaction
	 * is added implicitly. 
	 * 
	 * @return True if the graph did not already contain the specified vertex.
	 */	
	@Override
	public boolean addVertex(Vertex vertex) {
		
		if (vertex.getType() == Vertex.REACTION && vertex.isReversed())
			throw new IllegalArgumentException("Method not applicable for reversed reactions, they are added implicitly.");
		
		if (super.addVertex(vertex)) {
			
			if (vertex.getType() == Vertex.REACTION) {
				
				if (this.reversible && vertex.reversedReaction() == null)
					throw new RuntimeException("Cannot add a non-reversible reaction to a reversible graph.");
				
				// avoid duplicate reaction names: set a unique name
				String name = vertex.getName();
				int i=1;
				while (reactions.get(name) != null)
					name = vertex.getName()+"$"+(i++);
				// set new name of the reaction, and possibly its reversed reaction
				vertex.setName(name);
				if (vertex.reversedReaction() != null)
					vertex.reversedReaction().setName(name);
				// add reaction name to hash map
				if (reactions.put(vertex.getName(), vertex) != null)
					throw new RuntimeException("Reaction name "+vertex.getName()+" already in HashMap! Redundant call of addVertex?");
				// add the reversed reaction
				if (vertex.reversedReaction() != null)
					super.addVertex(vertex.reversedReaction());
				
				return true;
					
			} else if (vertex.getType() == Vertex.COMPOUND) {
				if (compounds.put(vertex.getName()+vertex.getCompartment(), vertex) != null)
					throw new RuntimeException("Compound name "+vertex.getName()+" already in HashMap! Redundant call of addVertex?");
				// add phosphate types
				int type = Properties.isPhosphate(vertex.getMass());
				if (type >= 0)
					phosphates.put(vertex.getCompartment()+type, vertex);
				else if (Properties.isHydrogen(vertex.getMass()))
					hydrogens.put(vertex.getCompartment(), vertex);
				
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Removes the vertex from the graph and removes the entry from the
	 * compounds or reactions HashMap. If the vertex is a reaction and a reversed
	 * reaction exists (vertex.reversedReaction()!=null), then the reversed
	 * reaction is also removed.
	 * 
	 * @return True if the graph contained the specified vertex, false otherwise.
	 */
	@Override
	public boolean removeVertex(Vertex vertex) {
		
		if (vertex.getType() == Vertex.REACTION) {
			
			if (vertex.isReversed())
				throw new IllegalArgumentException("Method not applicable for reversed reactions, they are added implicitly.");
			
			if (super.removeVertex(vertex)) {
				if (reactions.remove(vertex.getName()) == null)
					throw new RuntimeException("Vertex name "+vertex.getName()+" was not in reactions HashMap! Was it removed by a duplicate name?");
				if (vertex.reversedReaction() != null)
					super.removeVertex(vertex.reversedReaction());
				return true;
			}
		} else if (vertex.getType() == Vertex.COMPOUND){
			if (super.removeVertex(vertex)) {
				if (compounds.remove(vertex.getName()+vertex.getCompartment()) == null)
					throw new RuntimeException("Vertex name "+vertex.getName()+" was not in compounds HashMap! Was it removed by a duplicate name?");
				// remove phosphate types
				int type = Properties.isPhosphate(vertex.getMass());
				if (type >= 0)
					phosphates.remove(vertex.getCompartment()+type);
				else if (Properties.isHydrogen(vertex.getMass()))
					hydrogens.remove(vertex.getCompartment());
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Adds an edge to connect source and target. If the graph is reversible or 
	 * the reaction vertex has a reversed reaction, then the reversed edge is
	 * created implicitly. 
	 * 
	 * @return The new edge connecting source and target, or null if the edge could not be added
	 * (see <a href="http://www.jgrapht.org/javadoc/org/jgrapht/graph/AbstractBaseGraph.html#addEdge%28V,%20V%29">AbstractBaseGraph.addEdge(Vertex,Vertex)</a>).
	 */
	@Override
    public DefaultWeightedEdge addEdge(Vertex source, Vertex target) {
    	if (source.getType() == target.getType())
    		throw new IllegalArgumentException("Cannot connect vertices of the same type in a bipartite graph.");
    	
		if (source.getType() == Vertex.REACTION && source.isReversed() || target.getType() == Vertex.REACTION && target.isReversed())
			throw new IllegalArgumentException("Method not applicable for reversed reactions, they are added implicitly.");
    	
    	// add the reversed edge
    	if (source.getType() == Vertex.REACTION && source.reversedReaction() != null)
    		super.addEdge(target, source.reversedReaction());
    	else if (target.getType() == Vertex.REACTION && target.reversedReaction() != null)
    		super.addEdge(target.reversedReaction(), source);	
    	
    	// add the edge
    	return super.addEdge(source, target);
    }

	/**
	 * Adds the edge to connect source and target. If the graph is reversible or 
	 * the reaction vertex has a reversed reaction, then the reversed edge is
	 * created implicitly. 
	 * 
	 * @return The new edge connecting source and target, or null if the edge could not be added
	 * (see <a href="http://www.jgrapht.org/javadoc/org/jgrapht/graph/AbstractBaseGraph.html#addEdge%28V,%20V,%20E%29">AbstractBaseGraph.addEdge(Vertex,Vertex,E)</a>).
	 */
	@Override
	public boolean addEdge(Vertex source, Vertex target, DefaultWeightedEdge e) {
    	if (source.getType() == target.getType())
    		throw new IllegalArgumentException("Cannot connect vertices of the same type in a bipartite graph.");
		if (source.getType() == Vertex.REACTION && source.isReversed() || target.getType() == Vertex.REACTION && target.isReversed())
			throw new IllegalArgumentException("Method not applicable for reversed reactions, they are added implicitly.");
		if (getEdgeWeight(e) <= 0)
			throw new IllegalArgumentException("Invalid stoichiometric coefficient: "+getEdgeWeight(e)+" for edge "+getEdgeSource(e).getName()+" --> "+getEdgeTarget(e).getName()+" (must be larger than 0)");
    	
    	// add the reversed edge with the same weight
    	if (source.getType() == Vertex.REACTION && source.reversedReaction() != null)
    		super.setEdgeWeight(super.addEdge(target, source.reversedReaction()), getEdgeWeight(e));
    	else if (target.getType() == Vertex.REACTION && target.reversedReaction() != null)
    		super.setEdgeWeight(super.addEdge(target.reversedReaction(), source), getEdgeWeight(e));
    	
    	// add the edge
    	return super.addEdge(source, target, e);
	}
    
	/**
	 * Removes the edge connecting source and target. If the graph is reversible or 
	 * the reaction vertex has a reversed reaction, then also removes the
	 * corresponding edge of the reversed reaction.
	 * 
	 * @return The removed edge previously connecting source and target, or null if this edge did not exist. 
	 */
	@Override
    public DefaultWeightedEdge removeEdge(Vertex source, Vertex target) {
		
		if (source.getType() == Vertex.REACTION && source.isReversed() || target.getType() == Vertex.REACTION && target.isReversed())
			throw new IllegalArgumentException("Method not applicable for reversed reactions, they are added implicitly.");
		
    	// remove the reversed edge
		if (source.getType() == Vertex.REACTION && source.reversedReaction() != null)
			super.removeEdge(target, source.reversedReaction());
		else if (target.getType() == Vertex.REACTION && target.reversedReaction() != null)
			super.removeEdge(target.reversedReaction(), source);
    	
    	// remove the edge
    	return super.removeEdge(source, target);
    }
 
	/**
	 * Removes the edge. If the graph is reversible, also removes the corresponding edge of the reversed reaction.
	 * 
	 * @return True if the edge existed, false otherwise.
	 */
    @Override
    public boolean removeEdge(DefaultWeightedEdge e) {
    	return removeEdge(getEdgeSource(e), getEdgeTarget(e)) != null;
    }
    
    /**
	 * Sets the weight for the edge. If the graph is reversible or 
	 * the reaction vertex has a reversed reaction, then also sets the
	 * same weight for the edge of the reversed reaction.
	 * 
     */
    @Override
    public void setEdgeWeight(DefaultWeightedEdge e, double weight) {
    	Vertex source = getEdgeSource(e);
    	Vertex target = getEdgeTarget(e);
    	
		if (source.getType() == Vertex.REACTION && source.isReversed() || target.getType() == Vertex.REACTION && target.isReversed())
			throw new IllegalArgumentException("Method not applicable for reversed reactions, they are added implicitly.");
		if (weight <= 0)
			throw new IllegalArgumentException("Invalid stoichiometric coefficient: "+weight+" for edge "+getEdgeSource(e).getName()+" --> "+getEdgeTarget(e).getName()+" (must be larger than 0)");
    	
    	// set the weight of the reversed edge
    	if (source.getType() == Vertex.REACTION && source.reversedReaction() != null)
	    	super.setEdgeWeight(getEdge(target, source.reversedReaction()), weight);
    	else if (target.getType() == Vertex.REACTION && target.reversedReaction() != null)
	    	super.setEdgeWeight(getEdge(target.reversedReaction(), source), weight);
    	
    	super.setEdgeWeight(e, weight);
    }
    
    /**
     * Creates an identical copy of the graph: reversibility is copied, vertices are
     * copied with names, mass and reversible reactions, edges are copied with weights.
     */
    @Override
    public MetabolicGraph clone() {
    	boolean debug = false;
    	MetabolicGraph clonedGraph = new MetabolicGraph(this.reversible, this.compartments);
    	clonedGraph.version = this.version;
    	
    	// clone the vertices
    	for (Iterator<Vertex> vertexIterator = vertexSet().iterator(); vertexIterator.hasNext();) {
    		Vertex vertex = vertexIterator.next();
    		if (vertex.getType() == Vertex.REACTION && vertex.isReversed())
    			continue;
    		Vertex newVertex = vertex.clone();
			if (!clonedGraph.addVertex(newVertex))
				throw new RuntimeException("Vertex could not be added: "+newVertex.getName()+". Does it already exist?");
    	}
    	
    	// clone the weighted edges
    	for (Iterator<DefaultWeightedEdge> edgeIterator = edgeSet().iterator(); edgeIterator.hasNext();) {
    		DefaultWeightedEdge edge = edgeIterator.next();
    		Vertex source = getEdgeSource(edge);
    		Vertex target = getEdgeTarget(edge);
    		boolean left = (source.getType() == Vertex.COMPOUND);
    		boolean reversed = ((left && target.isReversed()) || !left && source.isReversed());
    		
    		// reversed edges are added implicitly
    		if (!reversed) {
	    		if (left) {
		    		Vertex compound = clonedGraph.getCompound(source.getName(), source.getCompartment());
		    		Vertex reaction = clonedGraph.getReaction(target.getName());
					if (debug)
						System.out.println("adding edge: "+compound.getName()+" "+compound+" ---> "+reaction.getName()+" "+reaction+(reaction.isReversed()?" (reversed)":""));
					DefaultWeightedEdge newEdge = clonedGraph.addEdge(compound, reaction);
					if (newEdge == null)
						throw new RuntimeException("Edge could not be added: "+compound.getName()+" ---> "+reaction.getName()+". Does it already exist?");
					clonedGraph.setEdgeWeight(newEdge, getEdgeWeight(edge));
	    		} else {
		    		Vertex compound = clonedGraph.getCompound(target.getName(), target.getCompartment());
		    		Vertex reaction = clonedGraph.getReaction(source.getName());
					if (debug)
						System.out.println("adding edge: "+reaction.getName()+" "+reaction+" ---> "+compound.getName()+" "+compound+(reaction.isReversed()?" (reversed)":""));
					DefaultWeightedEdge newEdge = clonedGraph.addEdge(reaction, compound);
					if (newEdge == null)
						throw new RuntimeException("Edge could not be added: "+reaction.getName()+" ---> "+compound.getName()+". Does it already exist?");
					clonedGraph.setEdgeWeight(newEdge, getEdgeWeight(edge));
	    		}
    		}
    	}
    	
    	return clonedGraph;
    }
    
    /**
     * Compares this MetabolicGraph to the given MetabolicGraph. Compares member variables
     * as well as the member variables of all vertices and all edges (their sources and targets).
     * 
     * Compares amongst others the following member variables:
     * - version
     * - isReversible()
     * - vertexSet().size()
     * - edgeSet().size()
     * - for every vertex v in vertexSet(): containsVertex(v) and v.compare()
     * - for every edge e in edgeSet():  containsEdge(e), getEdgeSource(e).compare(), getEdgeTarget(e).compare(),
     *   and getEdgeWeight(e).
     * 
     * @param graph
     * @return true, if the graphs are identical, false otherwixe.
     */
    public boolean compare(MetabolicGraph graph) {
    	
    	if (!this.version.equals(graph.version))
    		return false;
    	if (this.isAllowingLoops() != graph.isAllowingLoops())
    		return false;
    	if (this.isAllowingMultipleEdges() != graph.isAllowingMultipleEdges())
    		return false;
    	if (this.isReversible() != graph.isReversible())
    		return false;
    	if (this.vertexSet().size() != graph.vertexSet().size())
    		return false;
    	if (this.edgeSet().size() != graph.edgeSet().size())
    		return false;
    	
    	if (reversible) {
    		if (this.vertexSet().size() != getCompounds().size()+getReactions().size()*2)
    			return false;
    		if (graph.vertexSet().size() != getCompounds().size()+getReactions().size()*2)
    			return false;
    	} else {
    		if (getCompounds().size() != graph.getCompounds().size())
    			return false;
    		if (getReactions().size() != graph.getReactions().size())
    			return false;
    	}
    	
    	for (Vertex c1 : getCompounds()) {
    		Vertex c2 = graph.getCompound(c1.getName(), c1.getCompartment());
    		if (!this.containsVertex(c1) || !graph.containsVertex(c2))
    			return false;
    		if (!c1.compare(c2))
    			return false;
    	}
    	
    	for (Vertex reaction : getReactions()) {
    		Vertex r1 = getReaction(reaction.getName());
    		Vertex r2 = graph.getReaction(reaction.getName());
    		if (!r1.compare(r2))
    			return false;
    		if (!this.containsVertex(r1) || !graph.containsVertex(r2))
    			return false;
    		if (r1.reversedReaction() != null || r2.reversedReaction() != null)
    			if (!this.containsVertex(r1.reversedReaction()) || !graph.containsVertex(r2.reversedReaction()))
    				return false;
    	}
    	
    	for (DefaultWeightedEdge edge : edgeSet()) {
    		Vertex source1 = this.getEdgeSource(edge);
    		Vertex target1 = this.getEdgeTarget(edge);
    		Vertex reaction = (source1.getType() == Vertex.REACTION ? source1 : target1);
    		Vertex source2 = (source1.getType() == Vertex.COMPOUND ? graph.getCompound(source1.getName(), source1.getCompartment()) : graph.getReaction(source1.getName()));
    		Vertex target2 = (target1.getType() == Vertex.COMPOUND ? graph.getCompound(target1.getName(), target1.getCompartment()) : graph.getReaction(target1.getName()));
    		if (reaction.isReversed()) {
    			if (source2.getType() == Vertex.REACTION)
    				source2 = source2.reversedReaction();
    			else
    				target2 = target2.reversedReaction();
    		}
    		if (!graph.containsEdge(source2, target2))
    			return false;
    		if (!source1.compare(source2))
    			return false;
    		if (!target1.compare(target2))
    			return false;
    		if (getEdgeWeight(edge) != graph.getEdgeWeight(graph.getEdge(source2, target2)))
    			return false;
    	}
    	
    	return true;
    }
    
    /**
     * Compares the edges of this MetabolicGraph to the edges of the given MetabolicGraph. Compares the
     * member variables of all all edges (their sources and targets). The vertices must exist in both
     * graphs and have identical names and compartments.
     * 
     * Compares amongst others the following member variables:
     * - edgeSet().size()
     * - for every edge e in edgeSet():  containsEdge(e), getEdgeSource(e).compare(), getEdgeTarget(e).compare(),
     *   and getEdgeWeight(e).
     * 
     * @param graph
     * @return true, if the edge sets are equal, false otherwise.
     */
    public boolean compareEdges(MetabolicGraph graph) {
    	
    	if (this.edgeSet().size() != graph.edgeSet().size())
    		return false;
    	
    	for (DefaultWeightedEdge edge : edgeSet()) {
    		Vertex source1 = this.getEdgeSource(edge);
    		Vertex target1 = this.getEdgeTarget(edge);
    		Vertex reaction = (source1.getType() == Vertex.REACTION ? source1 : target1);
    		Vertex source2 = (source1.getType() == Vertex.COMPOUND ? graph.getCompound(source1.getName(), source1.getCompartment()) : graph.getReaction(source1.getName()));
    		Vertex target2 = (target1.getType() == Vertex.COMPOUND ? graph.getCompound(target1.getName(), target1.getCompartment()) : graph.getReaction(target1.getName()));
    		if (reaction.isReversed()) {
    			if (source2.getType() == Vertex.REACTION)
    				source2 = source2.reversedReaction();
    			else
    				target2 = target2.reversedReaction();
    		}
    		if (!graph.containsEdge(source2, target2))
    			return false;
    		if (!source1.compare(source2))
    			return false;
    		if (!target1.compare(target2))
    			return false;
    		if (getEdgeWeight(edge) != graph.getEdgeWeight(graph.getEdge(source2, target2)))
    			return false;
    	}
    	
    	return true;
    }
    
    /**
     * Writes the graph to a tab- and delimiter-separated file readable by createGraph.
     * 
     * @param outputFile
     * @throws IOException
     */
    public void write(String outputFile, boolean printAllCoefficients) throws IOException {
    	BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));
    	
    	writer.write("# "+version+"\n");
    	
    	ArrayList<Vertex> reactionsList = new ArrayList<Vertex>(getReactions());
    	Collections.sort(reactionsList, new VertexComparator());
    	
    	for (Vertex reaction : reactionsList) {
    		
    		writer.write(reaction.getName()+"\t");
    		for (Iterator<Vertex> substrates = Graphs.predecessorListOf(this, reaction).iterator(); substrates.hasNext();) {
    			Vertex substrate = substrates.next();
    			double weight = getEdgeWeight(getEdge(substrate, reaction));
    			if (printAllCoefficients || weight != 1)
    				writer.write(Utilities.DELIMITER_COEFFICIENT_START+String.valueOf((int)weight)+Utilities.DELIMITER_COEFFICIENT_END+" ");
				String name = substrate.getName();
				if (substrate.getCompartment() != null)
					name = name + Utilities.DELIMITER_COMPOUND_COMPARTMENT + substrate.getCompartment();
    			writer.write(name);
    			if (substrates.hasNext())
    				writer.write(" "+Utilities.DELIMITER_PLUS+" ");
    		}
    		
    		if (reversible || reaction.reversedReaction() != null)
    			writer.write(" "+Utilities.DELIMITER_EQUALS+" ");
    		else
    			writer.write(" "+Utilities.DELIMITER_FORWARD+" ");
    		
    		for (Iterator<Vertex> products = Graphs.successorListOf(this, reaction).iterator(); products.hasNext();) {
    			Vertex product = products.next();
    			double weight = (int)getEdgeWeight(getEdge(reaction, product));
    			if (printAllCoefficients || weight != 1)
    				writer.write(Utilities.DELIMITER_COEFFICIENT_START+String.valueOf((int)weight)+Utilities.DELIMITER_COEFFICIENT_END+" ");
				String name = product.getName();
				if (product.getCompartment() != null)
					name = name + Utilities.DELIMITER_COMPOUND_COMPARTMENT + product.getCompartment();
    			writer.write(name);
    			if (products.hasNext())
    				writer.write(" "+Utilities.DELIMITER_PLUS+" ");
    		}
    		writer.write("\n");
    	}
    	
    	writer.close();
    }
    
    /**
     * Writes the graph to an alternative tab- and delimiter-separated file format.
     * 
     * @param outputFile
     * @throws IOException
     */
    public void write2(String outputFile, boolean printAllCoefficients) throws IOException {
    	BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));
    	
//    	writer.write("## REACTIONS\n");
    	
    	ArrayList<Vertex> reactionsList = new ArrayList<Vertex>(getReactions());
    	Collections.sort(reactionsList, new VertexComparator());
    	
    	for (Vertex reaction : reactionsList) {
//    		writer.write("R"+reactions+": ");
    		writer.write(reaction.getName()+": ");
    		for (Iterator<Vertex> substrates = Graphs.predecessorListOf(this, reaction).iterator(); substrates.hasNext();) {
    			Vertex substrate = substrates.next();
    			double weight = getEdgeWeight(getEdge(substrate, reaction));
    			if (printAllCoefficients || weight != 1)
    				writer.write((int)weight+"*");
				String name = substrate.getName();
				// remove '+' and '-'
				name = name.replace("+", "").replace("-", "");
				if (substrate.getCompartment() != null)
					name = name + Utilities.DELIMITER_COMPOUND_COMPARTMENT + substrate.getCompartment();
    			writer.write(name+" ");
    			if (substrates.hasNext())
    				writer.write("+ ");
    		}
    		
    		if (reversible || reaction.reversedReaction() != null)
    			writer.write("<-> ");
    		else
    			writer.write("-> ");
    		
    		for (Iterator<Vertex> products = Graphs.successorListOf(this, reaction).iterator(); products.hasNext();) {
    			Vertex product = products.next();
    			double weight = (int)getEdgeWeight(getEdge(reaction, product));
    			if (printAllCoefficients || weight != 1)
    				writer.write((int)weight+"*");
				String name = product.getName();
				// remove '+' and '-'
				name = name.replace("+", "").replace("-", "");
				if (product.getCompartment() != null)
					name = name + Utilities.DELIMITER_COMPOUND_COMPARTMENT + product.getCompartment();
    			writer.write(name+" ");
    			if (products.hasNext())
    				writer.write("+ ");
    		}
    		writer.write("\n");
    	}
    	
//    	writer.write("### END REACTION\n\n## MAXIMISE\n\n## END MAXIMISE\n\n### INEQUALITIES\n\n### END INEQUALITIES\n\n### EQUATIONS\n\n### END EQUATIONS\n\n### COMPONENTS\nsucrose_c\nATP_c\nATP_p\nATP_m\nADP_c\nADP_p\nADP_m\nP_c\nP_p\nP_m\nF6P_c\nF6P_p\nGlc_c\nGlc_p\nG1P_c\nG1P_p\nG6P_c\nG6P_p\nPP_c\nPP_p\nUDPGlc_c\nUTP_c\nUDP_c\nFrc_c\nS6P_c\nF1_6P_c\nF1_6P_p\nDHAP_c\nDHAP_p\nGAP_c\nGAP_p\nNAD_pls_c\nNAD_pls_p\nNAD_pls_m\nNADH_c\nNADH_p\nNADH_m\n1_3BPG_c\n1_3BPG_p\n2PG_c\n2PG_p\n3PG_c\n3PG_p\nPEP_c\nPEP_p\nPyr_c\nPyr_p\nPyr_m\nNADP_pls_c\nNADP_pls_p\nNADP_pls_m\nNADPH_c\nNADPH_p\nNADPH_m\nAcCoA_p\nAcCoA_m\nOAA_c\nOAA_m\nCit_c\nCit_m\nCoA_p\nCoA_m\nIcit_c\nIcit_m\n2OG_c\n2OG_p\n2OG_m\nSuccCoA_p\nSuccCoA_m\nSucc_c\nSucc_p\nSucc_m\nQ_m\nQH2_m\nMal_c\nMal_p\nMal_m\nFum_c\nFum_p\nFum_m\nCO2_c\nCO2_p\nCO2_m\nADPglc_c\nADPglc_p\nGL6P_p\n6PG_p\nRu5P_p\nX5P_p\nR5P_p\nS7P_p\nE4P_p\nAcAl_c\nEth_c\nLac_c\nPHPyr_p\nGlu_c\nGlu_p\nGlu_m\nPser_p\nSer_p\nMETTHF_c\nMETTHF_p\nGly_p\nTHF_c\nTHF_p\nAcSer_p\nH2S_p\nH2S_c\nCys_p\nAcA_c\nAcA_p\nDAH7P_p\n3DHQ_p\n3DSh_p\nSh_p\nSh3P_p\nEPSP_p\nCh_p\nGln_c\nGln_p\nPRE_p\nAgn_p\nTyr_p\nPhe_p\nAcLac_p\nDIV_p\nOIV_p\nVal_p\n2IPM_p\n3IPM_p\nOIC_p\nLeu_p\nAla_c\nAsp_c\nAsp_p\nAsp_m\nAMP_c\nAMP_p\nAsn_c\nNH3_c\nNH3_p\nNH3_m\nPAsp_p\nAspSA_p\nHOMO_minus_Ser_p\nP_minus_HOMO_minus_Ser_p\nThr_p\nCysTh_p\nHOMO_minus_Cys_p\nMTHF_c\nMTHF_p\nMet_p\nDPA_p\nTHDPA_p\nSuccAH_p\nSuccDAH_p\nDAH_p\nmDAH_p\nLys_p\n2OB_p\n2AHB_p\nDMV_p\nOMV_p\nIle_p\nPyrrC_p\nPro_p\nAcGlu_p\nAcGluP_p\nAcGluSA_p\nAcOr_p\nOr_p\nCitru_c\nCitru_p\nCP_p\nArgSucc_c\nArg_c\nPRPP_p\nPR_minus_ATP_p\nPR_minus_AMP_p\nPR_minus_AICARP_p\nPRu_minus_AICARP_p\nIGP_p\nIAP_p\nHolP_p\nHol_p\nHis_p\nAICAR_p\nPRFICA_p\nMalt_p\nGluSA_p\nGaba_c\nGaba_m\nGTP_p\nGDP_p\nGlx_c\nO2_c\nO2_m\nFTHF_c\nFTHF_p\nIMP_p\nAsuc_p\nRu1_5P_p\nstarch_p\nSuccSAl_m\nB_minus_glucan_c\nUDPGlu_c\nUDPXyl_c\nUDPAra_c\nAraXyl_c\nCel_c\nFor_c\nOxl_c\nH_ext\nbiomass\nMETHF_c\nMet_c\nHOMO_minus_Cys_c\nSAM_c\nSAH_c\nADN_c\nCit_p\nOAA_p\nGly_m\nGly_c\nSer_m\nSer_c\nTHF_m\nMETTHF_m\nIPO_p\nGL6P_c\n6PG_c\nRu5P_c\nX5P_c\n### END COMPONENTS\n\n### EXTERNALS\nHALIMEX1\nHALIMEX2\nHALIMEX3\nHALIMEX4\nHALIMEX5\nHALIMEX6\n### END EXTERNALS\n");
    	
    	writer.close();
    }
    
    /**
     * Writes the number of balanced reactions and the number of reactions which are fully annotated,
     * i.e., of which all substrates and products have an annotated mass. The latter number may vary between
     * randomized graphs.
     * 
     * @param outputFile
     * @param append
     * @throws IOException
     */
    public void writeBalance(String outputFile, boolean append) throws IOException {
    	
		// write balanced ratio
		int balancedReactions = 0, annotated = 0;
		for (Vertex reaction : getReactions()) {
			int[] balance = balance(reaction);
			boolean balanced = true;
			if (balance != null) {
				annotated++;
				for (int j=0; j<balance.length; j++) {
					if (balance[j] != 0) {
						balanced = false;
						break;
					}
				}
				if (balanced)
					balancedReactions++;
			}
		}
		float balancedRatio = (annotated>0 ? (float)balancedReactions*100/annotated : 100);
		BufferedWriter balanceWriter = new BufferedWriter(new FileWriter(outputFile, append));
		balanceWriter.write(String.valueOf(balancedRatio)+"% of "+annotated+"\n");
		balanceWriter.close();
    }
    
    protected boolean checkReversibleWeights() {
    	for (DefaultWeightedEdge edge : edgeSet()) {
    		double weight = getEdgeWeight(edge);
    		Vertex source = getEdgeSource(edge);
    		Vertex target = getEdgeTarget(edge);
    		if (source.getType() == Vertex.REACTION) {
    			System.out.println(target.getName()+" ---> "+source.reversedReaction().getName()+" "+Utilities.DELIMITER_COEFFICIENT_START+getEdgeWeight(getEdge(target, source.reversedReaction()))+Utilities.DELIMITER_COEFFICIENT_END+"");
    			if (weight != getEdgeWeight(getEdge(target, source.reversedReaction())))
    				return false;
    		} else {
    			System.out.println(target.reversedReaction().getName()+" ---> "+source.getName()+" "+Utilities.DELIMITER_COEFFICIENT_START+getEdgeWeight(getEdge(target.reversedReaction(), source))+Utilities.DELIMITER_COEFFICIENT_END+"");
    			if (weight != getEdgeWeight(getEdge(target.reversedReaction(), source)))
    				return false;
    		}
    	}
    	return true;
    }
}
